diff -Naur solvers/minisatgh/Makefile solvers/mgh/Makefile
--- solvers/minisatgh/Makefile	1970-01-01 10:00:00
+++ solvers/mgh/Makefile	2021-08-12 09:10:25
@@ -0,0 +1,39 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     := minisatgh
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
+
+#-------------------------------------------------------------------------------
diff -Naur solvers/minisatgh/core/Solver.cc solvers/mgh/core/Solver.cc
--- solvers/minisatgh/core/Solver.cc	2023-01-13 19:24:17
+++ solvers/mgh/core/Solver.cc	2023-01-13 17:33:28
@@ -20,12 +20,12 @@
 
 #include <math.h>
 
-#include "minisat/mtl/Alg.h"
-#include "minisat/mtl/Sort.h"
-#include "minisat/utils/System.h"
-#include "minisat/core/Solver.h"
+#include "minisatgh/mtl/Alg.h"
+#include "minisatgh/core/Solver.h"
+#include "minisatgh/mtl/Sort.h"
+#include "minisatgh/utils/System.h"
 
-using namespace Minisat;
+using namespace MinisatGH;
 
 //=================================================================================================
 // Options:
@@ -94,6 +94,7 @@
   , simpDB_props       (0)
   , progress_estimate  (0)
   , remove_satisfied   (true)
+  , warm_start         (false)
   , next_var           (0)
 
     // Resource constraints:
@@ -127,7 +128,7 @@
 
     watches  .init(mkLit(v, false));
     watches  .init(mkLit(v, true ));
-    assigns  .insert(v, l_Undef);
+    assigns  .insert(v, mgh_l_Undef);
     vardata  .insert(v, mkVarData(CRef_Undef, 0));
     activity .insert(v, rnd_init_act ? drand(random_seed) * 0.00001 : 0);
     seen     .insert(v, 0);
@@ -144,7 +145,7 @@
 // releases of the same variable).
 void Solver::releaseVar(Lit l)
 {
-    if (value(l) == l_Undef){
+    if (value(l) == mgh_l_Undef){
         addClause(l);
         released_vars.push(var(l));
     }
@@ -160,9 +161,9 @@
     sort(ps);
     Lit p; int i, j;
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if (value(ps[i]) == l_True || ps[i] == ~p)
+        if (value(ps[i]) == mgh_l_True || ps[i] == ~p)
             return true;
-        else if (value(ps[i]) != l_False && ps[i] != p)
+        else if (value(ps[i]) != mgh_l_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
@@ -194,7 +195,7 @@
 void Solver::detachClause(CRef cr, bool strict){
     const Clause& c = ca[cr];
     assert(c.size() > 1);
-    
+
     // Strict or lazy detaching:
     if (strict){
         remove(watches[~c[0]], Watcher(cr, c[1]));
@@ -214,14 +215,14 @@
     detachClause(cr);
     // Don't leave pointers to free'd memory!
     if (locked(c)) vardata[var(c[0])].reason = CRef_Undef;
-    c.mark(1); 
+    c.mark(1);
     ca.free(cr);
 }
 
 
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) == l_True)
+        if (value(c[i]) == mgh_l_True)
             return true;
     return false; }
 
@@ -232,7 +233,7 @@
     if (decisionLevel() > level){
         for (int c = trail.size()-1; c >= trail_lim[level]; c--){
             Var      x  = var(trail[c]);
-            assigns [x] = l_Undef;
+            assigns [x] = mgh_l_Undef;
             if (phase_saving > 1 || (phase_saving == 1 && c > trail_lim.last()))
                 polarity[x] = sign(trail[c]);
             insertVarOrder(x); }
@@ -253,11 +254,11 @@
     // Random decision:
     if (drand(random_seed) < random_var_freq && !order_heap.empty()){
         next = order_heap[irand(random_seed,order_heap.size())];
-        if (value(next) == l_Undef && decision[next])
+        if (value(next) == mgh_l_Undef && decision[next])
             rnd_decisions++; }
 
     // Activity based decision:
-    while (next == var_Undef || value(next) != l_Undef || !decision[next])
+    while (next == var_Undef || value(next) != mgh_l_Undef || !decision[next])
         if (order_heap.empty()){
             next = var_Undef;
             break;
@@ -267,8 +268,8 @@
     // Choose polarity based on different polarity modes (global or per-variable):
     if (next == var_Undef)
         return lit_Undef;
-    else if (user_pol[next] != l_Undef)
-        return mkLit(next, user_pol[next] == l_True);
+    else if (user_pol[next] != mgh_l_Undef)
+        return mkLit(next, user_pol[next] == mgh_l_True);
     else if (rnd_pol)
         return mkLit(next, drand(random_seed) < 0.5);
     else
@@ -279,19 +280,19 @@
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
-|  
+|
 |  Description:
 |    Analyze conflict and produce a reason clause.
-|  
+|
 |    Pre-conditions:
 |      * 'out_learnt' is assumed to be cleared.
 |      * Current decision level must be greater than root level.
-|  
+|
 |    Post-conditions:
 |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
-|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
+|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
-|  
+|
 |________________________________________________________________________________________________@*/
 void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel)
 {
@@ -322,7 +323,7 @@
                     out_learnt.push(q);
             }
         }
-        
+
         // Select next clause to look at:
         while (!seen[var(trail[index--])]);
         p     = trail[index+1];
@@ -341,7 +342,7 @@
         for (i = j = 1; i < out_learnt.size(); i++)
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i]))
                 out_learnt[j++] = out_learnt[i];
-        
+
     }else if (ccmin_mode == 1){
         for (i = j = 1; i < out_learnt.size(); i++){
             Var x = var(out_learnt[i]);
@@ -399,11 +400,11 @@
         if (i < (uint32_t)c->size()){
             // Checking 'p'-parents 'l':
             Lit l = (*c)[i];
-            
+
             // Variable at level 0 or previously removable:
             if (level(var(l)) == 0 || seen[var(l)] == seen_source || seen[var(l)] == seen_removable){
                 continue; }
-            
+
             // Check variable can not be removed for some local reason:
             if (reason(var(l)) == CRef_Undef || seen[var(l)] == seen_failed){
                 stack.push(ShrinkStackElem(0, p));
@@ -412,7 +413,7 @@
                         seen[var(stack[i].l)] = seen_failed;
                         analyze_toclear.push(stack[i].l);
                     }
-                    
+
                 return false;
             }
 
@@ -430,7 +431,7 @@
 
             // Terminate with success if stack is empty:
             if (stack.size() == 0) break;
-            
+
             // Continue with top element on stack:
             i  = stack.last().i;
             p  = stack.last().l;
@@ -447,7 +448,7 @@
 /*_________________________________________________________________________________________________
 |
 |  analyzeFinal : (p : Lit)  ->  [void]
-|  
+|
 |  Description:
 |    Specialized analysis procedure to express the final conflict in terms of assumptions.
 |    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
@@ -485,21 +486,71 @@
 
 void Solver::uncheckedEnqueue(Lit p, CRef from)
 {
-    assert(value(p) == l_Undef);
+    assert(value(p) == mgh_l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
 }
 
+//=================================================================================================
+// Propagate and check:
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
 
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == mgh_l_False)
+            st = false;
+        else if (value(p) != mgh_l_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking
+        cancelUntil(level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
+
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
-|  
+|
 |  Description:
 |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
 |    otherwise CRef_Undef.
-|  
+|
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
 |________________________________________________________________________________________________@*/
@@ -517,7 +568,7 @@
         for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
+            if (value(blocker) == mgh_l_True){
                 *j++ = *i++; continue; }
 
             // Make sure the false literal is data[1]:
@@ -532,19 +583,19 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit     first = c[0];
             Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
+            if (first != blocker && value(first) == mgh_l_True){
                 *j++ = w; continue; }
 
             // Look for new watch:
             for (int k = 2; k < c.size(); k++)
-                if (value(c[k]) != l_False){
+                if (value(c[k]) != mgh_l_False){
                     c[1] = c[k]; c[k] = false_lit;
                     watches[~c[1]].push(w);
                     goto NextClause; }
 
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if (value(first) == l_False){
+            if (value(first) == mgh_l_False){
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -567,16 +618,16 @@
 /*_________________________________________________________________________________________________
 |
 |  reduceDB : ()  ->  [void]
-|  
+|
 |  Description:
 |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
 |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
 |________________________________________________________________________________________________@*/
-struct reduceDB_lt { 
+struct reduceDB_lt {
     ClauseAllocator& ca;
     reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
-    bool operator () (CRef x, CRef y) { 
-        return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); } 
+    bool operator () (CRef x, CRef y) {
+        return ca[x].size() > 2 && (ca[y].size() == 2 || ca[x].activity() < ca[y].activity()); }
 };
 void Solver::reduceDB()
 {
@@ -607,9 +658,9 @@
             removeClause(cs[i]);
         else{
             // Trim clause:
-            assert(value(c[0]) == l_Undef && value(c[1]) == l_Undef);
+            assert(value(c[0]) == mgh_l_Undef && value(c[1]) == mgh_l_Undef);
             for (int k = 2; k < c.size(); k++)
-                if (value(c[k]) == l_False){
+                if (value(c[k]) == mgh_l_False){
                     c[k--] = c[c.size()-1];
                     c.pop();
                 }
@@ -624,7 +675,7 @@
 {
     vec<Var> vs;
     for (Var v = 0; v < nVars(); v++)
-        if (decision[v] && value(v) == l_Undef)
+        if (decision[v] && value(v) == mgh_l_Undef)
             vs.push(v);
     order_heap.build(vs);
 }
@@ -633,7 +684,7 @@
 /*_________________________________________________________________________________________________
 |
 |  simplify : [void]  ->  [bool]
-|  
+|
 |  Description:
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
@@ -689,11 +740,11 @@
 /*_________________________________________________________________________________________________
 |
 |  search : (nof_conflicts : int) (params : const SearchParams&)  ->  [lbool]
-|  
+|
 |  Description:
-|    Search for a model the specified number of conflicts. 
+|    Search for a model the specified number of conflicts.
 |    NOTE! Use negative value for 'nof_conflicts' indicate infinity.
-|  
+|
 |  Output:
 |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
 |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
@@ -712,7 +763,7 @@
         if (confl != CRef_Undef){
             // CONFLICT
             conflicts++; conflictC++;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) return mgh_l_False;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level);
@@ -737,9 +788,9 @@
                 max_learnts             *= learntsize_inc;
 
                 if (verbosity >= 1)
-                    printf("| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n", 
-                           (int)conflicts, 
-                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
+                    printf("| %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n",
+                           (int)conflicts,
+                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
                            (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             }
 
@@ -749,11 +800,11 @@
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
                 cancelUntil(0);
-                return l_Undef; }
+                return mgh_l_Undef; }
 
             // Simplify the set of problem clauses:
             if (decisionLevel() == 0 && !simplify())
-                return l_False;
+                return mgh_l_False;
 
             if (learnts.size()-nAssigns() >= max_learnts)
                 // Reduce the set of learnt clauses:
@@ -763,12 +814,12 @@
             while (decisionLevel() < assumptions.size()){
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if (value(p) == l_True){
+                if (value(p) == mgh_l_True){
                     // Dummy decision level:
                     newDecisionLevel();
-                }else if (value(p) == l_False){
+                }else if (value(p) == mgh_l_False){
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return mgh_l_False;
                 }else{
                     next = p;
                     break;
@@ -782,7 +833,7 @@
 
                 if (next == lit_Undef)
                     // Model found:
-                    return l_True;
+                    return mgh_l_True;
             }
 
             // Increase decision level and enqueue 'next'
@@ -840,7 +891,7 @@
 {
     model.clear();
     conflict.clear();
-    if (!ok) return l_False;
+    if (!ok) return mgh_l_False;
 
     solves++;
 
@@ -850,7 +901,7 @@
 
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
     learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
-    lbool   status            = l_Undef;
+    lbool   status            = mgh_l_Undef;
 
     if (verbosity >= 1){
         printf("============================[ Search Statistics ]==============================\n");
@@ -861,7 +912,7 @@
 
     // Search:
     int curr_restarts = 0;
-    while (status == l_Undef){
+    while (status == mgh_l_Undef){
         double rest_base = luby_restart ? luby(restart_inc, curr_restarts) : pow(restart_inc, curr_restarts);
         status = search(rest_base * restart_first);
         if (!withinBudget()) break;
@@ -872,28 +923,142 @@
         printf("===============================================================================\n");
 
 
-    if (status == l_True){
+    if (status == mgh_l_True) {
         // Extend & copy model:
         model.growTo(nVars());
         for (int i = 0; i < nVars(); i++) model[i] = value(i);
-    }else if (status == l_False && conflict.size() == 0)
+    }else if (status == mgh_l_False && conflict.size() == 0)
         ok = false;
 
-    cancelUntil(0);
+    if (!warm_start || status != mgh_l_True)  // no 'default' backtracking in case of warm restarts
+        cancelUntil(0);
+
     return status;
 }
 
+//=================================================================================================
+// Add a clause in the warm start mode:
+bool Solver::addClauseWarm(vec<Lit>& ps)
+{
+    if (!ok) return false;
+    if (!warm_start || decisionLevel() == 0) return addClause(ps);
 
+    // checking if clause is satisfied and remove false/duplicate literals
+    sort(ps);
+    Lit p; int i, j, nws, max_i;
+    vec<int> ws(2, -1);  // potentially watched literals
+    for (i = j = nws = max_i = 0, p = lit_Undef; i < ps.size(); i++) {
+        Var x = var(ps[i]);
+        if ((value(ps[i]) == mgh_l_True && level(x) == 0) || ps[i] == ~p)
+            return true;
+        else if ((value(ps[i]) != mgh_l_False || level(x) > 0) && ps[i] != p) {
+            if (value(ps[i]) != mgh_l_False && nws < 2)
+                ws[nws++] = j;
+            if (level(x) > level(var(ps[max_i])))
+                max_i = j;
+
+            ps[j++] = p = ps[i];
+        }
+    }
+    ps.shrink(i - j);
+
+    // analyzing which level to backtrack to (if any)
+    if (ps.size() != 0) {
+        if (ps.size() > 1) {
+            if (nws) {
+                p = ps[0]; ps[0] = ps[ws[0]]; ps[ws[0]] = p;
+                if (nws == 2) {
+                    p = ps[1]; ps[1] = ps[ws[1]]; ps[ws[1]] = p;
+                }
+            }
+            else {
+                // no satisfied literals in this clause
+                p = ps[max_i]; ps[max_i] = ps[0]; ps[0] = p;
+
+                max_i = 1;
+                for (int i = 2; i < ps.size(); ++i) {
+                    if (level(var(ps[i])) > level(var(ps[max_i])))
+                        max_i = i;
+                }
+
+                p = ps[max_i]; ps[max_i] = ps[1]; ps[1] = p;
+
+                cancelUntil(level(var(p)));
+            }
+            CRef cr = ca.alloc(ps, false);
+            clauses.push(cr);
+            attachClause(cr);
+
+            if (!nws) {
+                // if the clause was falsified
+                if (value(ps[0]) == mgh_l_Undef)
+                    // enqueue unless already true
+                    uncheckedEnqueue(ps[0], cr);
+                else if (value(ps[0]) == mgh_l_False && resolveConflicts(cr) == false)
+                    ok = false;
+            }
+        }
+        else {
+            // a single literal in the clause => enqueue it at level 0
+            cancelUntil(0);
+            uncheckedEnqueue(ps[0]);
+            ok = (propagate() == CRef_Undef);
+        }
+    }
+    else {
+        // there is no literal left in the clause!
+        cancelUntil(0);
+        ok = false;
+    }
+
+    return ok;
+}
+
+//=================================================================================================
+// Resolve conflicts, if appear after adding a clause in the warm start mode:
+bool Solver::resolveConflicts(CRef confl)
+{
+    int      backtrack_level;
+    vec<Lit> learnt_clause;
+
+    while (confl != CRef_Undef) {
+        conflicts++;
+        if (decisionLevel() == 0) return false;
+
+        learnt_clause.clear();
+        analyze(confl, learnt_clause, backtrack_level);
+        cancelUntil(backtrack_level);
+
+        if (learnt_clause.size() == 1)
+            uncheckedEnqueue(learnt_clause[0]);
+        else {
+            CRef cr = ca.alloc(learnt_clause, true);
+            learnts.push(cr);
+            attachClause(cr);
+            claBumpActivity(ca[cr]);
+            uncheckedEnqueue(learnt_clause[0], cr);
+        }
+
+        varDecayActivity();
+        claDecayActivity();
+
+        confl = propagate();
+    }
+
+    return true;
+}
+
+
 bool Solver::implies(const vec<Lit>& assumps, vec<Lit>& out)
 {
     trail_lim.push(trail.size());
     for (int i = 0; i < assumps.size(); i++){
         Lit a = assumps[i];
 
-        if (value(a) == l_False){
+        if (value(a) == mgh_l_False){
             cancelUntil(0);
             return false;
-        }else if (value(a) == l_Undef)
+        }else if (value(a) == mgh_l_Undef)
             uncheckedEnqueue(a);
     }
 
@@ -905,14 +1070,14 @@
             out.push(trail[j]);
     }else
         ret = false;
-    
+
     cancelUntil(0);
     return ret;
 }
 
 //=================================================================================================
 // Writing CNF to DIMACS:
-// 
+//
 // FIXME: this needs to be rewritten completely.
 
 static Var mapVar(Var x, vec<Var>& map, Var& max)
@@ -930,7 +1095,7 @@
     if (satisfied(c)) return;
 
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) != l_False)
+        if (value(c[i]) != mgh_l_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
     fprintf(f, "0\n");
 }
@@ -961,12 +1126,12 @@
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]]))
             cnt++;
-        
+
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]])){
             Clause& c = ca[clauses[i]];
             for (int j = 0; j < c.size(); j++)
-                if (value(c[j]) != l_False)
+                if (value(c[j]) != mgh_l_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -976,7 +1141,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for (int i = 0; i < assumps.size(); i++){
-        assert(value(assumps[i]) != l_False);
+        assert(value(assumps[i]) != mgh_l_False);
         fprintf(f, "%s%d 0\n", sign(assumps[i]) ? "-" : "", mapVar(var(assumps[i]), map, max)+1);
     }
 
@@ -992,11 +1157,11 @@
 {
     double cpu_time = cpuTime();
     double mem_used = memUsedPeak();
-    printf("restarts              : %"PRIu64"\n", starts);
-    printf("conflicts             : %-12"PRIu64"   (%.0f /sec)\n", conflicts   , conflicts   /cpu_time);
-    printf("decisions             : %-12"PRIu64"   (%4.2f %% random) (%.0f /sec)\n", decisions, (float)rnd_decisions*100 / (float)decisions, decisions   /cpu_time);
-    printf("propagations          : %-12"PRIu64"   (%.0f /sec)\n", propagations, propagations/cpu_time);
-    printf("conflict literals     : %-12"PRIu64"   (%4.2f %% deleted)\n", tot_literals, (max_literals - tot_literals)*100 / (double)max_literals);
+    printf("restarts              : %" PRIu64"\n", starts);
+    printf("conflicts             : %-12" PRIu64"   (%.0f /sec)\n", conflicts   , conflicts   /cpu_time);
+    printf("decisions             : %-12" PRIu64"   (%4.2f %% random) (%.0f /sec)\n", decisions, (float)rnd_decisions*100 / (float)decisions, decisions   /cpu_time);
+    printf("propagations          : %-12" PRIu64"   (%.0f /sec)\n", propagations, propagations/cpu_time);
+    printf("conflict literals     : %-12" PRIu64"   (%4.2f %% deleted)\n", tot_literals, (max_literals - tot_literals)*100 / (double)max_literals);
     if (mem_used != 0) printf("Memory used           : %.2f MB\n", mem_used);
     printf("CPU time              : %g s\n", cpu_time);
 }
@@ -1056,11 +1221,11 @@
 {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
-    ClauseAllocator to(ca.size() - ca.wasted()); 
+    ClauseAllocator to(ca.size() - ca.wasted());
 
     relocAll(to);
     if (verbosity >= 2)
-        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n", 
+        printf("|  Garbage collection:   %12d bytes => %12d bytes             |\n",
                ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
     to.moveTo(ca);
 }
diff -Naur solvers/minisatgh/core/Solver.h solvers/mgh/core/Solver.h
--- solvers/minisatgh/core/Solver.h	2023-01-13 19:24:17
+++ solvers/mgh/core/Solver.h	2023-01-13 17:04:52
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Solver_h
-#define Minisat_Solver_h
+#ifndef MinisatGH_Solver_h
+#define MinisatGH_Solver_h
 
-#include "minisat/mtl/Vec.h"
-#include "minisat/mtl/Heap.h"
-#include "minisat/mtl/Alg.h"
-#include "minisat/mtl/IntMap.h"
-#include "minisat/utils/Options.h"
-#include "minisat/core/SolverTypes.h"
+#include "minisatgh/mtl/Vec.h"
+#include "minisatgh/mtl/Heap.h"
+#include "minisatgh/mtl/Alg.h"
+#include "minisatgh/mtl/IntMap.h"
+#include "minisatgh/utils/Options.h"
+#include "minisatgh/core/SolverTypes.h"
 
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Solver -- the main class:
@@ -44,15 +44,15 @@
 
     // Problem specification:
     //
-    Var     newVar    (lbool upol = l_Undef, bool dvar = true); // Add a new variable with parameters specifying variable mode.
+    Var     newVar    (lbool upol = mgh_l_Undef, bool dvar = true); // Add a new variable with parameters specifying variable mode.
     void    releaseVar(Lit l);                                  // Make literal true and promise to never refer to variable again.
 
-    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver. 
+    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver.
     bool    addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
-    bool    addClause (Lit p);                                  // Add a unit clause to the solver. 
-    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver. 
-    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver. 
-    bool    addClause (Lit p, Lit q, Lit r, Lit s);             // Add a quaternary clause to the solver. 
+    bool    addClause (Lit p);                                  // Add a unit clause to the solver.
+    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver.
+    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver.
+    bool    addClause (Lit p, Lit q, Lit r, Lit s);             // Add a quaternary clause to the solver.
     bool    addClause_(      vec<Lit>& ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                 // change the passed vector 'ps'.
 
@@ -66,6 +66,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
     bool    implies      (const vec<Lit>& assumps, vec<Lit>& out);
 
@@ -84,9 +85,9 @@
     void    toDimacs     (const char* file, Lit p);
     void    toDimacs     (const char* file, Lit p, Lit q);
     void    toDimacs     (const char* file, Lit p, Lit q, Lit r);
-    
+
     // Variable mode:
-    // 
+    //
     void    setPolarity    (Var v, lbool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
     void    setDecisionVar (Var v, bool b);  // Declare if a variable should be eligible for selection in the decision heuristic.
 
@@ -102,6 +103,11 @@
     int     nVars      ()      const;       // The current number of variables.
     int     nFreeVars  ()      const;
     void    printStats ()      const;       // Print some current statistics to standard output.
+                                            //
+    // Warm start mode:
+    void setStartMode(bool warm = false);
+    bool addClauseWarm(vec<Lit>& ps);
+    bool resolveConflicts(CRef confl);
 
     // Resource contraints:
     //
@@ -212,6 +218,7 @@
     int64_t             simpDB_props;     // Remaining number of propagations that must be made before next execution of 'simplify()'.
     double              progress_estimate;// Set by 'search()'.
     bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
+    bool                warm_start;       // Warm start if set to true.
     Var                 next_var;         // Next variable to be created.
     ClauseAllocator     ca;
 
@@ -333,8 +340,8 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
-inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != mgh_l_Undef ? value(p) != mgh_l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); if (warm_start && decisionLevel()) return addClauseWarm(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
@@ -342,7 +349,7 @@
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r, Lit s){ add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); add_tmp.push(s); return addClause_(add_tmp); }
 
 inline bool     Solver::isRemoved       (CRef cr)         const { return ca[cr].mark() == 1; }
-inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
+inline bool     Solver::locked          (const Clause& c) const { return value(c[0]) == mgh_l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c; }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
 inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
@@ -358,8 +365,8 @@
 // TODO: nFreeVars() is not quite correct, try to calculate right instead of adapting it like below:
 inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
 inline void     Solver::setPolarity   (Var v, lbool b){ user_pol[v] = b; }
-inline void     Solver::setDecisionVar(Var v, bool b) 
-{ 
+inline void     Solver::setDecisionVar(Var v, bool b)
+{
     if      ( b && !decision[v]) dec_vars++;
     else if (!b &&  decision[v]) dec_vars--;
 
@@ -379,24 +386,27 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == mgh_l_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == mgh_l_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == mgh_l_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == mgh_l_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == mgh_l_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
 inline ClauseIterator Solver::clausesBegin() const { return ClauseIterator(ca, &clauses[0]); }
 inline ClauseIterator Solver::clausesEnd  () const { return ClauseIterator(ca, &clauses[clauses.size()]); }
 inline TrailIterator  Solver::trailBegin  () const { return TrailIterator(&trail[0]); }
-inline TrailIterator  Solver::trailEnd    () const { 
+inline TrailIterator  Solver::trailEnd    () const {
     return TrailIterator(&trail[decisionLevel() == 0 ? trail.size() : trail_lim[0]]); }
 
 inline void     Solver::toDimacs     (const char* file){ vec<Lit> as; toDimacs(file, as); }
 inline void     Solver::toDimacs     (const char* file, Lit p){ vec<Lit> as; as.push(p); toDimacs(file, as); }
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }
+
+// Warm start mode:
+inline void     Solver::setStartMode (bool warm) { warm_start = warm; cancelUntil(0); }
 
 
 //=================================================================================================
diff -Naur solvers/minisatgh/core/SolverTypes.h solvers/mgh/core/SolverTypes.h
--- solvers/minisatgh/core/SolverTypes.h	2023-01-13 19:24:17
+++ solvers/mgh/core/SolverTypes.h	2021-08-12 09:10:25
@@ -19,19 +19,20 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_SolverTypes_h
-#define Minisat_SolverTypes_h
+#ifndef MinisatGH_SolverTypes_h
+#define MinisatGH_SolverTypes_h
 
+#define MINISAT_CONSTANTS_AS_MACROS
 #include <assert.h>
 
-#include "minisat/mtl/IntTypes.h"
-#include "minisat/mtl/Alg.h"
-#include "minisat/mtl/Vec.h"
-#include "minisat/mtl/IntMap.h"
-#include "minisat/mtl/Map.h"
-#include "minisat/mtl/Alloc.h"
+#include "minisatgh/mtl/IntTypes.h"
+#include "minisatgh/mtl/Alg.h"
+#include "minisatgh/mtl/Vec.h"
+#include "minisatgh/mtl/IntMap.h"
+#include "minisatgh/mtl/Map.h"
+#include "minisatgh/mtl/Alloc.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -47,12 +48,14 @@
   const Var var_Undef = -1;
 #endif
 
+struct Lit;
+Lit mkLit(Var var, bool sign = false);
 
 struct Lit {
     int     x;
 
     // Use this as a constructor:
-    friend Lit mkLit(Var var, bool sign = false);
+    friend Lit mkLit(Var var, bool sign);
 
     bool operator == (Lit p) const { return x == p.x; }
     bool operator != (Lit p) const { return x != p.x; }
@@ -87,7 +90,7 @@
 // Lifted booleans:
 //
 // NOTE: this implementation is optimized for the case when comparisons between values are mostly
-//       between one variable and one constant. Some care had to be taken to make sure that gcc 
+//       between one variable and one constant. Some care had to be taken to make sure that gcc
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
@@ -121,13 +124,13 @@
 inline lbool toLbool(int   v) { return lbool((uint8_t)v);  }
 
 #if defined(MINISAT_CONSTANTS_AS_MACROS)
-  #define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-  #define l_False (lbool((uint8_t)1))
-  #define l_Undef (lbool((uint8_t)2))
+  #define mgh_l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+  #define mgh_l_False (lbool((uint8_t)1))
+  #define mgh_l_Undef (lbool((uint8_t)2))
 #else
-  const lbool l_True ((uint8_t)0);
-  const lbool l_False((uint8_t)1);
-  const lbool l_Undef((uint8_t)2);
+  const lbool mgh_l_True ((uint8_t)0);
+  const lbool mgh_l_False((uint8_t)1);
+  const lbool mgh_l_Undef((uint8_t)2);
 #endif
 
 
diff -Naur solvers/minisatgh/mtl/Alg.h solvers/mgh/mtl/Alg.h
--- solvers/minisatgh/mtl/Alg.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Alg.h	2021-08-12 09:10:25
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Alg_h
-#define Minisat_Alg_h
+#ifndef MinisatGH_Alg_h
+#define MinisatGH_Alg_h
 
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur solvers/minisatgh/mtl/Alloc.h solvers/mgh/mtl/Alloc.h
--- solvers/minisatgh/mtl/Alloc.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Alloc.h	2021-08-12 09:10:25
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_Alloc_h
-#define Minisat_Alloc_h
+#ifndef MinisatGH_Alloc_h
+#define MinisatGH_Alloc_h
 
-#include "minisat/mtl/XAlloc.h"
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/XAlloc.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
diff -Naur solvers/minisatgh/mtl/Heap.h solvers/mgh/mtl/Heap.h
--- solvers/minisatgh/mtl/Heap.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Heap.h	2021-08-12 09:10:25
@@ -18,13 +18,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Heap_h
-#define Minisat_Heap_h
+#ifndef MinisatGH_Heap_h
+#define MinisatGH_Heap_h
 
-#include "minisat/mtl/Vec.h"
-#include "minisat/mtl/IntMap.h"
+#include "minisatgh/mtl/Vec.h"
+#include "minisatgh/mtl/IntMap.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
diff -Naur solvers/minisatgh/mtl/IntMap.h solvers/mgh/mtl/IntMap.h
--- solvers/minisatgh/mtl/IntMap.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/IntMap.h	2021-08-12 09:10:25
@@ -16,12 +16,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_IntMap_h
-#define Minisat_IntMap_h
+#ifndef MinisatGH_IntMap_h
+#define MinisatGH_IntMap_h
 
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
     template<class T> struct MkIndexDefault {
         typename vec<T>::Size operator()(T t) const { return (typename vec<T>::Size)t; }
diff -Naur solvers/minisatgh/mtl/IntTypes.h solvers/mgh/mtl/IntTypes.h
--- solvers/minisatgh/mtl/IntTypes.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/IntTypes.h	2021-08-12 09:10:25
@@ -17,8 +17,10 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_IntTypes_h
-#define Minisat_IntTypes_h
+#ifndef MinisatGH_IntTypes_h
+#define MinisatGH_IntTypes_h
+#define __STDC_FORMAT_MACROS
+#define __STDC_LIMIT_MACROS
 
 #ifdef __sun
     // Not sure if there are newer versions that support C99 headers. The
diff -Naur solvers/minisatgh/mtl/Map.h solvers/mgh/mtl/Map.h
--- solvers/minisatgh/mtl/Map.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Map.h	2021-08-12 09:10:25
@@ -17,13 +17,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Map_h
-#define Minisat_Map_h
+#ifndef MinisatGH_Map_h
+#define MinisatGH_Map_h
 
-#include "minisat/mtl/IntTypes.h"
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/IntTypes.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
+static inline uint32_t hash(uint32_t x){ return x; }
+static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
+static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
+static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
 
 //=================================================================================================
 // Default hash/equals functions
@@ -35,10 +39,6 @@
 template<class K> struct DeepHash  { uint32_t operator()(const K* k)               const { return hash(*k);  } };
 template<class K> struct DeepEqual { bool     operator()(const K* k1, const K* k2) const { return *k1 == *k2; } };
 
-static inline uint32_t hash(uint32_t x){ return x; }
-static inline uint32_t hash(uint64_t x){ return (uint32_t)x; }
-static inline uint32_t hash(int32_t x) { return (uint32_t)x; }
-static inline uint32_t hash(int64_t x) { return (uint32_t)x; }
 
 
 //=================================================================================================
diff -Naur solvers/minisatgh/mtl/Queue.h solvers/mgh/mtl/Queue.h
--- solvers/minisatgh/mtl/Queue.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Queue.h	2021-08-12 09:10:25
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Queue_h
-#define Minisat_Queue_h
+#ifndef MinisatGH_Queue_h
+#define MinisatGH_Queue_h
 
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 
diff -Naur solvers/minisatgh/mtl/Rnd.h solvers/mgh/mtl/Rnd.h
--- solvers/minisatgh/mtl/Rnd.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Rnd.h	2021-08-12 09:10:25
@@ -16,12 +16,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Rnd_h
-#define Minisat_Rnd_h
+#ifndef MinisatGH_Rnd_h
+#define MinisatGH_Rnd_h
 
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/Vec.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 // Generate a random double:
 static inline double drand(double& seed)
diff -Naur solvers/minisatgh/mtl/Sort.h solvers/mgh/mtl/Sort.h
--- solvers/minisatgh/mtl/Sort.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Sort.h	2021-08-12 09:10:25
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Sort_h
-#define Minisat_Sort_h
+#ifndef MinisatGH_Sort_h
+#define MinisatGH_Sort_h
 
-#include "minisat/mtl/Vec.h"
+#include "minisatgh/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Minisat {
+namespace MinisatGH {
 
 template<class T>
 struct LessThan_default {
diff -Naur solvers/minisatgh/mtl/Vec.h solvers/mgh/mtl/Vec.h
--- solvers/minisatgh/mtl/Vec.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/Vec.h	2021-08-12 09:10:25
@@ -18,17 +18,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Vec_h
-#define Minisat_Vec_h
+#ifndef MinisatGH_Vec_h
+#define MinisatGH_Vec_h
 
 #include <assert.h>
 #include <limits>
 #include <new>
 
-#include "minisat/mtl/IntTypes.h"
-#include "minisat/mtl/XAlloc.h"
+#include "minisatgh/mtl/IntTypes.h"
+#include "minisatgh/mtl/XAlloc.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Automatically resizable arrays
diff -Naur solvers/minisatgh/mtl/XAlloc.h solvers/mgh/mtl/XAlloc.h
--- solvers/minisatgh/mtl/XAlloc.h	2023-01-13 19:24:17
+++ solvers/mgh/mtl/XAlloc.h	2021-08-12 09:10:25
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_XAlloc_h
-#define Minisat_XAlloc_h
+#ifndef MinisatGH_XAlloc_h
+#define MinisatGH_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 
-namespace Minisat {
+namespace MinisatGH {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur solvers/minisatgh/utils/Options.cc solvers/mgh/utils/Options.cc
--- solvers/minisatgh/utils/Options.cc	2023-01-13 19:24:17
+++ solvers/mgh/utils/Options.cc	2021-08-12 09:10:25
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "minisat/mtl/Sort.h"
-#include "minisat/utils/Options.h"
-#include "minisat/utils/ParseUtils.h"
+#include "minisatgh/mtl/Sort.h"
+#include "minisatgh/utils/Options.h"
+#include "minisatgh/utils/ParseUtils.h"
 
-using namespace Minisat;
+using namespace MinisatGH;
 
-void Minisat::parseOptions(int& argc, char** argv, bool strict)
+void MinisatGH::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -55,9 +55,9 @@
 }
 
 
-void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Minisat::printUsageAndExit (int /*argc*/, char** argv, bool verbose)
+void MinisatGH::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void MinisatGH::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void MinisatGH::printUsageAndExit (int /*argc*/, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
diff -Naur solvers/minisatgh/utils/Options.h solvers/mgh/utils/Options.h
--- solvers/minisatgh/utils/Options.h	2023-01-13 19:24:17
+++ solvers/mgh/utils/Options.h	2021-08-12 09:10:25
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Options_h
-#define Minisat_Options_h
+#ifndef MinisatGH_Options_h
+#define MinisatGH_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "minisat/mtl/IntTypes.h"
-#include "minisat/mtl/Vec.h"
-#include "minisat/utils/ParseUtils.h"
+#include "minisatgh/mtl/IntTypes.h"
+#include "minisatgh/mtl/Vec.h"
+#include "minisatgh/utils/ParseUtils.h"
 
-namespace Minisat {
+namespace MinisatGH {
 
 //==================================================================================================
 // Top-level option parse/help functions:
@@ -282,15 +282,15 @@
         if (range.begin == INT64_MIN)
             fprintf(stderr, "imin");
         else
-            fprintf(stderr, "%4"PRIi64, range.begin);
+            fprintf(stderr, "%4" PRIi64, range.begin);
 
         fprintf(stderr, " .. ");
         if (range.end == INT64_MAX)
             fprintf(stderr, "imax");
         else
-            fprintf(stderr, "%4"PRIi64, range.end);
+            fprintf(stderr, "%4" PRIi64, range.end);
 
-        fprintf(stderr, "] (default: %"PRIi64")\n", value);
+        fprintf(stderr, "] (default: %" PRIi64")\n", value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
@@ -307,7 +307,7 @@
 {
     const char* value;
  public:
-    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) 
+    StringOption(const char* c, const char* n, const char* d, const char* def = NULL)
         : Option(n, d, c, "<string>"), value(def) {}
 
     operator      const char*  (void) const     { return value; }
diff -Naur solvers/minisatgh/utils/ParseUtils.h solvers/mgh/utils/ParseUtils.h
--- solvers/minisatgh/utils/ParseUtils.h	2023-01-13 19:24:17
+++ solvers/mgh/utils/ParseUtils.h	2021-08-12 09:10:25
@@ -18,88 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_ParseUtils_h
-#define Minisat_ParseUtils_h
+#ifndef MinisatGH_ParseUtils_h
+#define MinisatGH_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
 
-#include <zlib.h>
+namespace MinisatGH {
 
-#include "minisat/mtl/XAlloc.h"
-
-namespace Minisat {
-
-//-------------------------------------------------------------------------------------------------
-// A simple buffered character stream class:
-
-
-
-class StreamBuffer {
-    gzFile         in;
-    unsigned char* buf;
-    int            pos;
-    int            size;
-
-    enum { buffer_size = 64*1024 };
-
-    void assureLookahead() {
-        if (pos >= size) {
-            pos  = 0;
-            size = gzread(in, buf, buffer_size); } }
-
-public:
-    explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0){
-        buf = (unsigned char*)xrealloc(NULL, buffer_size);
-        assureLookahead();
-    }
-    ~StreamBuffer() { free(buf); }
-
-    int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }
-    void operator ++ ()       { pos++; assureLookahead(); }
-    int  position    () const { return pos; }
-};
-
-
-//-------------------------------------------------------------------------------------------------
-// End-of-file detection functions for StreamBuffer and char*:
-
-
-static inline bool isEof(StreamBuffer& in) { return *in == EOF;  }
-static inline bool isEof(const char*   in) { return *in == '\0'; }
-
-//-------------------------------------------------------------------------------------------------
-// Generic parse functions parametrized over the input-stream type.
-
-
-template<class B>
-static void skipWhitespace(B& in) {
-    while ((*in >= 9 && *in <= 13) || *in == 32)
-        ++in; }
-
-
-template<class B>
-static void skipLine(B& in) {
-    for (;;){
-        if (isEof(in)) return;
-        if (*in == '\n') { ++in; return; }
-        ++in; } }
-
-
-template<class B>
-static int parseInt(B& in) {
-    int     val = 0;
-    bool    neg = false;
-    skipWhitespace(in);
-    if      (*in == '-') neg = true, ++in;
-    else if (*in == '+') ++in;
-    if (*in < '0' || *in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-    while (*in >= '0' && *in <= '9')
-        val = val*10 + (*in - '0'),
-        ++in;
-    return neg ? -val : val; }
-
-
 // String matching: in case of a match the input iterator will be advanced the corresponding
 // number of characters.
 template<class B>
@@ -111,17 +37,8 @@
 
     in += i;
 
-    return true; 
+    return true;
 }
-
-// String matching: consumes characters eagerly, but does not require random access iterator.
-template<class B>
-static bool eagerMatch(B& in, const char* str) {
-    for (; *str != '\0'; ++str, ++in)
-        if (*str != *in)
-            return false;
-    return true; }
-
 
 //=================================================================================================
 }
diff -Naur solvers/minisatgh/utils/System.cc solvers/mgh/utils/System.cc
--- solvers/minisatgh/utils/System.cc	2023-01-13 19:24:17
+++ solvers/mgh/utils/System.cc	2021-08-12 09:14:04
@@ -21,13 +21,13 @@
 #include <signal.h>
 #include <stdio.h>
 
-#include "minisat/utils/System.h"
+#include "minisatgh/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdlib.h>
 
-using namespace Minisat;
+using namespace MinisatGH;
 
 static inline int memReadStat(int field)
 {
@@ -66,48 +66,37 @@
     return peak_kb;
 }
 
-double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Minisat::memUsedPeak(bool strictlyPeak) { 
-    double peak = memReadPeak() / (double)1024;
-    return peak == 0 && !strictlyPeak ? memUsed() : peak; }
+double MinisatGH::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double MinisatGH::memUsedPeak() {
+    double peak = memReadPeak() / 1024;
+    return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__gnu_hurd__)
 
-double Minisat::memUsed() {
+double MinisatGH::memUsed() {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
-double Minisat::memUsedPeak() { return memUsed(); }
+double MinisatGH::memUsedPeak() { return memUsed(); }
 
 
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Minisat::memUsed() {
+double MinisatGH::memUsed() {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
-double Minisat::memUsedPeak() { return memUsed(); }
+double MinisatGH::memUsedPeak() { return memUsed(); }
 
 #else
-double Minisat::memUsed()     { return 0; }
-double Minisat::memUsedPeak() { return 0; }
+double MinisatGH::memUsed()     { return 0; }
+double MinisatGH::memUsedPeak() { return 0; }
 #endif
 
 
-void Minisat::setX86FPUPrecision()
-{
-#if defined(__linux__) && defined(_FPU_EXTENDED) && defined(_FPU_DOUBLE) && defined(_FPU_GETCW)
-    // Only correct FPU precision on Linux architectures that needs and supports it:
-    fpu_control_t oldcw, newcw;
-    _FPU_GETCW(oldcw); newcw = (oldcw & ~_FPU_EXTENDED) | _FPU_DOUBLE; _FPU_SETCW(newcw);
-    printf("WARNING: for repeatability, setting FPU to use double precision\n");
-#endif
-}
-
-
 #if !defined(_MSC_VER) && !defined(__MINGW32__)
-void Minisat::limitMemory(uint64_t max_mem_mb)
+void MinisatGH::limitMemory(uint64_t max_mem_mb)
 {
 // FIXME: OpenBSD does not support RLIMIT_AS. Not sure how well RLIMIT_DATA works instead.
 #if defined(__OpenBSD__)
@@ -131,7 +120,7 @@
 #endif
 }
 #else
-void Minisat::limitMemory(uint64_t /*max_mem_mb*/)
+void MinisatGH::limitMemory(uint64_t /*max_mem_mb*/)
 {
     printf("WARNING! Memory limit not supported on this architecture.\n");
 }
@@ -139,7 +128,7 @@
 
 
 #if !defined(_MSC_VER) && !defined(__MINGW32__)
-void Minisat::limitTime(uint32_t max_cpu_time)
+void MinisatGH::limitTime(uint32_t max_cpu_time)
 {
     if (max_cpu_time != 0){
         rlimit rl;
@@ -152,14 +141,14 @@
     }
 }
 #else
-void Minisat::limitTime(uint32_t /*max_cpu_time*/)
+void MinisatGH::limitTime(uint32_t /*max_cpu_time*/)
 {
     printf("WARNING! CPU-time limit not supported on this architecture.\n");
 }
 #endif
 
 
-void Minisat::sigTerm(void handler(int))
+void MinisatGH::sigTerm(void handler(int))
 {
     signal(SIGINT, handler);
     signal(SIGTERM,handler);
diff -Naur solvers/minisatgh/utils/System.h solvers/mgh/utils/System.h
--- solvers/minisatgh/utils/System.h	2023-01-13 19:24:17
+++ solvers/mgh/utils/System.h	2021-08-12 09:13:48
@@ -18,27 +18,20 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_System_h
-#define Minisat_System_h
+#ifndef MinisatGH_System_h
+#define MinisatGH_System_h
 
-#if defined(__linux__)
-#include <fpu_control.h>
-#endif
+#include "minisatgh/mtl/IntTypes.h"
 
-#include "minisat/mtl/IntTypes.h"
-
 //-------------------------------------------------------------------------------------------------
 
-namespace Minisat {
+namespace MinisatGH {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 
 extern double memUsed();            // Memory in mega bytes (returns 0 for unsupported architectures).
-extern double memUsedPeak(bool strictlyPeak = false); // Peak-memory in mega bytes (returns 0 for unsupported architectures).
+extern double memUsedPeak();        // Peak-memory in mega bytes (returns 0 for unsupported architectures).
 
-extern void   setX86FPUPrecision(); // Make sure double's are represented with the same precision
-                                    // in memory and registers.
-
 extern void   limitMemory(uint64_t max_mem_mb); // Set a limit on total memory usage. The exact
                                                 // semantics varies depending on architecture.
 
@@ -55,14 +48,14 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Minisat::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double MinisatGH::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Minisat::cpuTime(void) {
+static inline double MinisatGH::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
