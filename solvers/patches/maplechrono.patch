diff -Naur solvers/maplechrono/Makefile solvers/chrono/Makefile
--- solvers/maplechrono/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ solvers/chrono/Makefile	2019-03-16 09:43:17.000000000 +0000
@@ -0,0 +1,39 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  maplechrono
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
+
+#-------------------------------------------------------------------------------
diff -Naur solvers/maplechrono/core/Solver.cc solvers/chrono/core/Solver.cc
--- solvers/maplechrono/core/Solver.cc	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/core/Solver.cc	2019-03-19 09:31:51.000000000 +0000
@@ -1,14 +1,14 @@
 /***************************************************************************************[Solver.cc]
 MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
            Copyright (c) 2007-2010, Niklas Sorensson
- 
+
 Chanseok Oh's MiniSat Patch Series -- Copyright (c) 2015, Chanseok Oh
- 
+
 Maple_LCM, Based on MapleCOMSPS_DRUP -- Copyright (c) 2017, Mao Luo, Chu-Min LI, Fan Xiao: implementing a learnt clause minimisation approach
 Reference: M. Luo, C.-M. Li, F. Xiao, F. Manya, and Z. L. , “An effective learnt clause minimization approach for cdcl sat solvers,” in IJCAI-2017, 2017, pp. to–appear.
 
 Maple_LCM_Dist, Based on Maple_LCM -- Copyright (c) 2017, Fan Xiao, Chu-Min LI, Mao Luo: using a new branching heuristic called Distance at the beginning of search
- 
+
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute,
@@ -30,14 +30,14 @@
 #include <signal.h>
 #include <unistd.h>
 
-#include "mtl/Sort.h"
-#include "core/Solver.h"
+#include "maplechrono/mtl/Sort.h"
+#include "maplechrono/core/Solver.h"
 
-using namespace Minisat;
+using namespace MapleChrono;
 
-//#define PRINT_OUT
+//#define MAPLECHRONO_PRINT_OUT
 
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
 int Solver::buf_len = 0;
 unsigned char Solver::drup_buf[2 * 1024 * 1024];
 unsigned char* Solver::buf_ptr = drup_buf;
@@ -76,6 +76,7 @@
     // Parameters (user settable):
     //
     drup_file        (NULL)
+  , drup_pyfile      (NULL)
   , verbosity        (0)
   , step_size        (opt_step_size)
   , step_size_dec    (opt_step_size_dec)
@@ -119,6 +120,7 @@
   , simpDB_props       (0)
   , order_heap_CHB     (VarOrderLt(activity_CHB))
   , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
+  , order_heap_distance(VarOrderLt(activity_distance))
   , progress_estimate  (0)
   , remove_satisfied   (true)
 
@@ -129,7 +131,7 @@
   , next_L_reduce      (15000)
   , confl_to_chrono    (opt_conf_to_chrono)
   , chrono			   (opt_chrono)
-  
+
   , counter            (0)
 
   // Resource constraints:
@@ -147,10 +149,9 @@
   , nbconfbeforesimplify(1000)
   , incSimplify(1000)
 
+  , var_iLevel_inc     (1)
   , my_var_decay       (0.6)
   , DISTANCE           (true)
-  , var_iLevel_inc     (1)
-  , order_heap_distance(VarOrderLt(activity_distance))
 
 {}
 
@@ -184,12 +185,12 @@
 
             Lit imp = wbin[k].blocker;
 
-            if (value(imp) == l_False)
+            if (value(imp) == chrl_False)
             {
                 return wbin[k].cref;
             }
 
-            if (value(imp) == l_Undef)
+            if (value(imp) == chrl_Undef)
             {
                 simpleUncheckEnqueue(imp, wbin[k].cref);
             }
@@ -198,7 +199,7 @@
         {
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True)
+            if (value(blocker) == chrl_True)
             {
                 *j++ = *i++; continue;
             }
@@ -217,7 +218,7 @@
             // why not simply do i->blocker=first in this case?
             Lit     first = c[0];
             //  Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True)
+            if (first != blocker && value(first) == chrl_True)
             {
                 i->blocker = first;
                 *j++ = *i++; continue;
@@ -229,7 +230,7 @@
             //	int choosenPos = -1;
             //	for (int k = 2; k < c.size(); k++)
             //	{
-            //		if (value(c[k]) != l_False)
+            //		if (value(c[k]) != chrl_False)
             //		{
             //			if (decisionLevel()>assumptions.size())
             //			{
@@ -240,7 +241,7 @@
             //			{
             //				choosenPos = k;
 
-            //				if (value(c[k]) == l_True || !isSelector(var(c[k]))) {
+            //				if (value(c[k]) == chrl_True || !isSelector(var(c[k]))) {
             //					break;
             //				}
             //			}
@@ -263,7 +264,7 @@
                 for (int k = 2; k < c.size(); k++)
                 {
 
-                    if (value(c[k]) != l_False)
+                    if (value(c[k]) != chrl_False)
                     {
                         // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
                         // the blocker is first in the watcher. However,
@@ -279,7 +280,7 @@
             // Did not find watch -- clause is unit under assignment:
             i->blocker = first;
             *j++ = *i++;
-            if (value(first) == l_False)
+            if (value(first) == chrl_False)
             {
                 confl = cr;
                 qhead = trail.size();
@@ -302,7 +303,7 @@
 }
 
 void Solver::simpleUncheckEnqueue(Lit p, CRef from){
-    assert(value(p) == l_Undef);
+    assert(value(p) == chrl_Undef);
     assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     vardata[var(p)].reason = from;
     trail.push_(p);
@@ -313,7 +314,7 @@
     for (int c = trail.size() - 1; c >= trailRecord; c--)
     {
         Var x = var(trail[c]);
-        assigns[x] = l_Undef;
+        assigns[x] = chrl_Undef;
 
     }
     qhead = trailRecord;
@@ -345,9 +346,9 @@
             Clause& c = ca[confl];
             // Special case for binary clauses
             // The first one has to be SAT
-            if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+            if (p != lit_Undef && c.size() == 2 && value(c[0]) == chrl_False) {
 
-                assert(value(c[1]) == l_True);
+                assert(value(c[1]) == chrl_True);
                 Lit tmp = c[0];
                 c[0] = c[1], c[1] = tmp;
             }
@@ -397,8 +398,8 @@
     CRef confl;
 
     for (i = 0, j = 0; i < c.size(); i++){
-        if (value(c[i]) == l_Undef){
-            //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
+        if (value(c[i]) == chrl_Undef){
+            //printf("///@@@ uncheckedEnqueue:index = %d. chrl_Undef\n", i);
             simpleUncheckEnqueue(~c[i]);
             c[j++] = c[i];
             confl = simplePropagate();
@@ -407,15 +408,15 @@
             }
         }
         else{
-            if (value(c[i]) == l_True){
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
+            if (value(c[i]) == chrl_True){
+                //printf("///@@@ uncheckedEnqueue:index = %d. chrl_True\n", i);
                 c[j++] = c[i];
                 True_confl = true;
                 confl = reason(var(c[i]));
                 break;
             }
             else{
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
+                //printf("///@@@ uncheckedEnqueue:index = %d. chrl_False\n", i);
                 falseLit.push(c[i]);
             }
         }
@@ -451,7 +452,7 @@
 bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
 {
     int beforeSize, afterSize;
-    int learnts_x_size_before = learnts_x.size();
+    // int learnts_x_size_before = learnts_x.size();
 
     int ci, cj, li, lj;
     bool sat, false_lit;
@@ -478,11 +479,11 @@
             nbSimplifing++;
             sat = false_lit = false;
             for (int i = 0; i < c.size(); i++){
-                if (value(c[i]) == l_True){
+                if (value(c[i]) == chrl_True){
                     sat = true;
                     break;
                 }
-                else if (value(c[i]) == l_False){
+                else if (value(c[i]) == chrl_False){
                     false_lit = true;
                 }
             }
@@ -494,7 +495,7 @@
 
                 if (false_lit){
                     for (li = lj = 0; li < c.size(); li++){
-                        if (value(c[li]) != l_False){
+                        if (value(c[li]) != chrl_False){
                             c[lj++] = c[li];
                         }
                     }
@@ -530,19 +531,19 @@
                         //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
                         c.set_lbd(nblevels);
                     }
-                    if (c.mark() != CORE){
+                    if (c.mark() != MAPLECHRONO_CORE){
                         if (c.lbd() <= core_lbd_cut){
-                            //if (c.mark() == LOCAL) local_learnts_dirty = true;
+                            //if (c.mark() == MAPLECHRONO_LOCAL) local_learnts_dirty = true;
                             //else tier2_learnts_dirty = true;
                             cj--;
                             learnts_core.push(cr);
-                            c.mark(CORE);
+                            c.mark(MAPLECHRONO_CORE);
                         }
-                        else if (c.mark() == LOCAL && c.lbd() <= 6){
+                        else if (c.mark() == MAPLECHRONO_LOCAL && c.lbd() <= 6){
                             //local_learnts_dirty = true;
                             cj--;
                             learnts_tier2.push(cr);
-                            c.mark(TIER2);
+                            c.mark(MAPLECHRONO_TIER2);
                         }
                     }
 
@@ -562,7 +563,7 @@
 bool Solver::simplifyLearnt_core()
 {
     int beforeSize, afterSize;
-    int learnts_core_size_before = learnts_core.size();
+    // int learnts_core_size_before = learnts_core.size();
 
     int ci, cj, li, lj;
     bool sat, false_lit;
@@ -593,11 +594,11 @@
             nbSimplifing++;
             sat = false_lit = false;
             for (int i = 0; i < c.size(); i++){
-                if (value(c[i]) == l_True){
+                if (value(c[i]) == chrl_True){
                     sat = true;
                     break;
                 }
-                else if (value(c[i]) == l_False){
+                else if (value(c[i]) == chrl_False){
                     false_lit = true;
                 }
             }
@@ -609,7 +610,7 @@
 
                 if (false_lit){
                     for (li = lj = 0; li < c.size(); li++){
-                        if (value(c[li]) != l_False){
+                        if (value(c[li]) != chrl_False){
                             c[lj++] = c[li];
                         }
                     }
@@ -622,14 +623,14 @@
                 simplifyLearnt(c);
                 assert(c.size() > 0);
                 afterSize = c.size();
-                
+
                 if(drup_file && saved_size !=c.size()){
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
                     binDRUP('a', c , drup_file);
                     //                    binDRUP('d', add_oc, drup_file);
 #else
                     for (int i = 0; i < c.size(); i++)
-                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
+                        fprintf(drup_file, "%i ", var(c[i]) * (-2 * sign(c[i]) + 1));
                     fprintf(drup_file, "0\n");
 
                     //                    fprintf(drup_file, "d ");
@@ -651,7 +652,7 @@
                     // delete the clause memory in logic
                     c.mark(1);
                     ca.free(cr);
-//#ifdef BIN_DRUP
+//#ifdef MAPLECHRONO_BIN_DRUP
 //                    binDRUP('d', c, drup_file);
 //#else
 //                    fprintf(drup_file, "d ");
@@ -687,7 +688,7 @@
 bool Solver::simplifyLearnt_tier2()
 {
     int beforeSize, afterSize;
-    int learnts_tier2_size_before = learnts_tier2.size();
+    // int learnts_tier2_size_before = learnts_tier2.size();
 
     int ci, cj, li, lj;
     bool sat, false_lit;
@@ -718,11 +719,11 @@
             nbSimplifing++;
             sat = false_lit = false;
             for (int i = 0; i < c.size(); i++){
-                if (value(c[i]) == l_True){
+                if (value(c[i]) == chrl_True){
                     sat = true;
                     break;
                 }
-                else if (value(c[i]) == l_False){
+                else if (value(c[i]) == chrl_False){
                     false_lit = true;
                 }
             }
@@ -734,7 +735,7 @@
 
                 if (false_lit){
                     for (li = lj = 0; li < c.size(); li++){
-                        if (value(c[li]) != l_False){
+                        if (value(c[li]) != chrl_False){
                             c[lj++] = c[li];
                         }
                     }
@@ -747,15 +748,15 @@
                 simplifyLearnt(c);
                 assert(c.size() > 0);
                 afterSize = c.size();
-                
+
                 if(drup_file && saved_size!=c.size()){
 
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
                     binDRUP('a', c , drup_file);
                     //                    binDRUP('d', add_oc, drup_file);
 #else
                     for (int i = 0; i < c.size(); i++)
-                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
+                        fprintf(drup_file, "%i ", var(c[i]) * (-2 * sign(c[i]) + 1));
                     fprintf(drup_file, "0\n");
 
                     //                    fprintf(drup_file, "d ");
@@ -777,7 +778,7 @@
                     // delete the clause memory in logic
                     c.mark(1);
                     ca.free(cr);
-//#ifdef BIN_DRUP
+//#ifdef MAPLECHRONO_BIN_DRUP
 //                    binDRUP('d', c, drup_file);
 //#else
 //                    fprintf(drup_file, "d ");
@@ -799,7 +800,7 @@
                     if (c.lbd() <= core_lbd_cut){
                         cj--;
                         learnts_core.push(cr);
-                        c.mark(CORE);
+                        c.mark(MAPLECHRONO_CORE);
                     }
 
                     c.setSimplified(true);
@@ -825,8 +826,8 @@
         return ok = false;
 
     //// cleanLearnts(also can delete these code), here just for analyzing
-    //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
-    //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
+    //if (local_learnts_dirty) cleanLearnts(learnts_local, MAPLECHRONO_LOCAL);
+    //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, MAPLECHRONO_TIER2);
     //local_learnts_dirty = tier2_learnts_dirty = false;
 
     if (!simplifyLearnt_core()) return ok = false;
@@ -855,7 +856,7 @@
     watches_bin.init(mkLit(v, true ));
     watches  .init(mkLit(v, false));
     watches  .init(mkLit(v, true ));
-    assigns  .push(l_Undef);
+    assigns  .push(chrl_Undef);
     vardata  .push(mkVarData(CRef_Undef, 0));
     activity_CHB  .push(0);
     activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
@@ -863,7 +864,7 @@
     picked.push(0);
     conflicted.push(0);
     almost_conflicted.push(0);
-#ifdef ANTI_EXPLORATION
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
     canceled.push(0);
 #endif
 
@@ -896,24 +897,24 @@
         for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
 
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if (value(ps[i]) == l_True || ps[i] == ~p)
+        if (value(ps[i]) == chrl_True || ps[i] == ~p)
             return true;
-        else if (value(ps[i]) != l_False && ps[i] != p)
+        else if (value(ps[i]) != chrl_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
     if (drup_file && i != j){
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
         binDRUP('a', ps, drup_file);
         binDRUP('d', add_oc, drup_file);
 #else
         for (int i = 0; i < ps.size(); i++)
-            fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
+            fprintf(drup_file, "%i ", var(ps[i]) * (-2 * sign(ps[i]) + 1));
         fprintf(drup_file, "0\n");
 
         fprintf(drup_file, "d ");
         for (int i = 0; i < add_oc.size(); i++)
-            fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
+            fprintf(drup_file, "%i ", var(add_oc[i]) * (-2 * sign(add_oc[i]) + 1));
         fprintf(drup_file, "0\n");
 #endif
     }
@@ -947,7 +948,7 @@
     const Clause& c = ca[cr];
     assert(c.size() > 1);
     OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
-    
+
     if (strict){
         remove(ws[~c[0]], Watcher(cr, c[1]));
         remove(ws[~c[1]], Watcher(cr, c[0]));
@@ -966,12 +967,12 @@
 
     if (drup_file){
         if (c.mark() != 1){
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
             binDRUP('d', c, drup_file);
 #else
             fprintf(drup_file, "d ");
             for (int i = 0; i < c.size(); i++)
-                fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
+                fprintf(drup_file, "%i ", var(c[i]) * (-2 * sign(c[i]) + 1));
             fprintf(drup_file, "0\n");
 #endif
         }else
@@ -981,7 +982,7 @@
     detachClause(cr);
     // Don't leave pointers to free'd memory!
     if (locked(c)){
-        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
+        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == chrl_True ? c[0] : c[1]);
         vardata[var(implied)].reason = CRef_Undef; }
     c.mark(1);
     ca.free(cr);
@@ -990,7 +991,7 @@
 
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) == l_True)
+        if (value(c[i]) == chrl_True)
             return true;
     return false; }
 
@@ -998,11 +999,11 @@
 // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
 //
 void Solver::cancelUntil(int bLevel) {
-	
+
     if (decisionLevel() > bLevel){
-#ifdef PRINT_OUT
+#ifdef MAPLECHRONO_PRINT_OUT
 		std::cout << "bt " << bLevel << "\n";
-#endif				
+#endif
 		add_tmp.clear();
         for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
         {
@@ -1027,16 +1028,16 @@
 								order_heap_CHB.increase(x);
 						}
 					}
-#ifdef ANTI_EXPLORATION
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
 					canceled[x] = conflicts;
 #endif
 				}
-				
-				assigns [x] = l_Undef;
-#ifdef PRINT_OUT
+
+				assigns [x] = chrl_Undef;
+#ifdef MAPLECHRONO_PRINT_OUT
 				std::cout << "undo " << x << "\n";
-#endif				
-	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
+#endif
+	            if (phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last()))
 					polarity[x] = sign(trail[c]);
 				insertVarOrder(x);
 			}
@@ -1048,7 +1049,7 @@
 		{
 			trail.push_(add_tmp[nLitId]);
 		}
-		
+
 		add_tmp.clear();
     } }
 
@@ -1066,15 +1067,15 @@
     // Random decision:
     /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
         next = order_heap[irand(random_seed,order_heap.size())];
-        if (value(next) == l_Undef && decision[next])
+        if (value(next) == chrl_Undef && decision[next])
             rnd_decisions++; }*/
 
     // Activity based decision:
-    while (next == var_Undef || value(next) != l_Undef || !decision[next])
+    while (next == var_Undef || value(next) != chrl_Undef || !decision[next])
         if (order_heap.empty())
             return lit_Undef;
         else{
-#ifdef ANTI_EXPLORATION
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
             if (!VSIDS){
                 Var v = order_heap_CHB[0];
                 uint32_t age = conflicts - canceled[v];
@@ -1142,19 +1143,19 @@
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
-|  
+|
 |  Description:
 |    Analyze conflict and produce a reason clause.
-|  
+|
 |    Pre-conditions:
 |      * 'out_learnt' is assumed to be cleared.
 |      * Current decision level must be greater than root level.
-|  
+|
 |    Post-conditions:
 |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
-|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
+|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
-|  
+|
 |________________________________________________________________________________________________@*/
 void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
 {
@@ -1173,30 +1174,30 @@
         Clause& c = ca[confl];
 
         // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
-        if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
-            assert(value(c[1]) == l_True);
+        if (p != lit_Undef && c.size() == 2 && value(c[0]) == chrl_False){
+            assert(value(c[1]) == chrl_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp; }
 
         // Update LBD if improved.
-        if (c.learnt() && c.mark() != CORE){
+        if (c.learnt() && c.mark() != MAPLECHRONO_CORE){
             int lbd = computeLBD(c);
             if (lbd < c.lbd()){
                 if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
                 c.set_lbd(lbd);
                 if (lbd <= core_lbd_cut){
                     learnts_core.push(confl);
-                    c.mark(CORE);
-                }else if (lbd <= 6 && c.mark() == LOCAL){
-                    // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
-                    // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
+                    c.mark(MAPLECHRONO_CORE);
+                }else if (lbd <= 6 && c.mark() == MAPLECHRONO_LOCAL){
+                    // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from MAPLECHRONO_TIER2
+                    // to MAPLECHRONO_LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
                     learnts_tier2.push(confl);
-                    c.mark(TIER2); }
+                    c.mark(MAPLECHRONO_TIER2); }
             }
 
-            if (c.mark() == TIER2)
+            if (c.mark() == MAPLECHRONO_TIER2)
                 c.touched() = conflicts;
-            else if (c.mark() == LOCAL)
+            else if (c.mark() == MAPLECHRONO_LOCAL)
                 claBumpActivity(c);
         }
 
@@ -1216,13 +1217,13 @@
                     out_learnt.push(q);
             }
         }
-        
+
         // Select next clause to look at:
 		do {
 			while (!seen[var(trail[index--])]);
 			p  = trail[index+1];
 		} while (level(var(p)) < nDecisionLevel);
-		
+
         confl = reason(var(p));
         seen[var(p)] = 0;
         pathC--;
@@ -1242,7 +1243,7 @@
         for (i = j = 1; i < out_learnt.size(); i++)
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
                 out_learnt[j++] = out_learnt[i];
-        
+
     }else if (ccmin_mode == 1){
         for (i = j = 1; i < out_learnt.size(); i++){
             Var x = var(out_learnt[i]);
@@ -1326,7 +1327,7 @@
     for (int i = 0; i < ws.size(); i++){
         Lit the_other = ws[i].blocker;
         // Does 'the_other' appear negatively in 'out_learnt'?
-        if (seen2[var(the_other)] == counter && value(the_other) == l_True){
+        if (seen2[var(the_other)] == counter && value(the_other) == chrl_True){
             to_remove++;
             seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
         }
@@ -1355,8 +1356,8 @@
         Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
 
         // Special handling for binary clauses like in 'analyze()'.
-        if (c.size() == 2 && value(c[0]) == l_False){
-            assert(value(c[1]) == l_True);
+        if (c.size() == 2 && value(c[0]) == chrl_False){
+            assert(value(c[1]) == chrl_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp; }
 
@@ -1384,7 +1385,7 @@
 /*_________________________________________________________________________________________________
 |
 |  analyzeFinal : (p : Lit)  ->  [void]
-|  
+|
 |  Description:
 |    Specialized analysis procedure to express the final conflict in terms of assumptions.
 |    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
@@ -1422,13 +1423,13 @@
 
 void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 {
-    assert(value(p) == l_Undef);
+    assert(value(p) == chrl_Undef);
     Var x = var(p);
     if (!VSIDS){
         picked[x] = conflicts;
         conflicted[x] = 0;
         almost_conflicted[x] = 0;
-#ifdef ANTI_EXPLORATION
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
         uint32_t age = conflicts - canceled[var(p)];
         if (age > 0){
             double decay = pow(0.95, age);
@@ -1445,14 +1446,75 @@
 }
 
 
+//=================================================================================================
+// Propagate and check:
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
+
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == chrl_False)
+            st = false;
+        else if (value(p) != chrl_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        // here we may choose a wrong literal
+        // in Glucose if the clause is binary!
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking (simplistic cancelUntil())
+        for (int c = trail.size() - 1; c >= trail_lim[level]; --c) {
+            Var      x  = var(trail[c]);
+            assigns [x] = chrl_Undef;
+            insertVarOrder(x);
+        }
+
+        qhead = trail_lim[level];
+        trail.shrink(trail.size() - trail_lim[level]);
+        trail_lim.shrink(trail_lim.size() - level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
+
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
-|  
+|
 |  Description:
 |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
 |    otherwise CRef_Undef.
-|  
+|
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
 |________________________________________________________________________________________________@*/
@@ -1473,26 +1535,26 @@
         vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
         for (int k = 0; k < ws_bin.size(); k++){
             Lit the_other = ws_bin[k].blocker;
-            if (value(the_other) == l_False){
+            if (value(the_other) == chrl_False){
                 confl = ws_bin[k].cref;
-#ifdef LOOSE_PROP_STAT
+#ifdef MAPLECHRONO_LOOSE_PROP_STAT
                 return confl;
 #else
                 goto ExitProp;
 #endif
-            }else if(value(the_other) == l_Undef)
+            }else if(value(the_other) == chrl_Undef)
             {
                 uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
-#ifdef  PRINT_OUT                
+#ifdef MAPLECHRONO_PRINT_OUT
                 std::cout << "i " << the_other << " l " << currLevel << "\n";
-#endif                
+#endif
 			}
         }
 
         for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
+            if (value(blocker) == chrl_True){
                 *j++ = *i++; continue; }
 
             // Make sure the false literal is data[1]:
@@ -1507,19 +1569,19 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit     first = c[0];
             Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
+            if (first != blocker && value(first) == chrl_True){
                 *j++ = w; continue; }
 
             // Look for new watch:
             for (int k = 2; k < c.size(); k++)
-                if (value(c[k]) != l_False){
+                if (value(c[k]) != chrl_False){
                     c[1] = c[k]; c[k] = false_lit;
                     watches[~c[1]].push(w);
                     goto NextClause; }
 
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if (value(first) == l_False){
+            if (value(first) == chrl_False){
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -1530,9 +1592,9 @@
 				if (currLevel == decisionLevel())
 				{
 					uncheckedEnqueue(first, currLevel, cr);
-#ifdef PRINT_OUT					
+#ifdef MAPLECHRONO_PRINT_OUT
 					std::cout << "i " << first << " l " << currLevel << "\n";
-#endif					
+#endif
 				}
 				else
 				{
@@ -1552,14 +1614,14 @@
 					if (nMaxInd != 1)
 					{
 						std::swap(c[1], c[nMaxInd]);
-						*j--; // undo last watch
+						j--; // undo last watch
 						watches[~c[1]].push(w);
 					}
-					
+
 					uncheckedEnqueue(first, nMaxLevel, cr);
-#ifdef PRINT_OUT					
+#ifdef MAPLECHRONO_PRINT_OUT
 					std::cout << "i " << first << " l " << nMaxLevel << "\n";
-#endif	
+#endif
 				}
 			}
 
@@ -1568,9 +1630,11 @@
         ws.shrink(i - j);
     }
 
+#ifndef MAPLECHRONO_LOOSE_PROP_STAT
 ExitProp:;
     propagations += num_props;
     simpDB_props -= num_props;
+#endif
 
     return confl;
 }
@@ -1579,12 +1643,12 @@
 /*_________________________________________________________________________________________________
 |
 |  reduceDB : ()  ->  [void]
-|  
+|
 |  Description:
 |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
 |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
 |________________________________________________________________________________________________@*/
-struct reduceDB_lt { 
+struct reduceDB_lt {
     ClauseAllocator& ca;
     reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
     bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
@@ -1592,7 +1656,7 @@
 void Solver::reduceDB()
 {
     int     i, j;
-    //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
+    //if (local_learnts_dirty) cleanLearnts(learnts_local, MAPLECHRONO_LOCAL);
     //local_learnts_dirty = false;
 
     sort(learnts_local, reduceDB_lt(ca));
@@ -1600,13 +1664,14 @@
     int limit = learnts_local.size() / 2;
     for (i = j = 0; i < learnts_local.size(); i++){
         Clause& c = ca[learnts_local[i]];
-        if (c.mark() == LOCAL)
+        if (c.mark() == MAPLECHRONO_LOCAL) {
             if (c.removable() && !locked(c) && i < limit)
                 removeClause(learnts_local[i]);
             else{
                 if (!c.removable()) limit++;
                 c.removable(true);
                 learnts_local[j++] = learnts_local[i]; }
+        }
     }
     learnts_local.shrink(i - j);
 
@@ -1617,15 +1682,16 @@
     int i, j;
     for (i = j = 0; i < learnts_tier2.size(); i++){
         Clause& c = ca[learnts_tier2[i]];
-        if (c.mark() == TIER2)
+        if (c.mark() == MAPLECHRONO_TIER2) {
             if (!locked(c) && c.touched() + 30000 < conflicts){
                 learnts_local.push(learnts_tier2[i]);
-                c.mark(LOCAL);
+                c.mark(MAPLECHRONO_LOCAL);
                 //c.removable(true);
                 c.activity() = 0;
                 claBumpActivity(c);
             }else
                 learnts_tier2[j++] = learnts_tier2[i];
+        }
     }
     learnts_tier2.shrink(i - j);
 }
@@ -1649,11 +1715,12 @@
     int i, j;
     for (i = j = 0; i < cs.size(); i++){
         Clause& c = ca[cs[i]];
-        if (c.mark() == valid_mark)
+        if (c.mark() == valid_mark) {
             if (satisfied(c))
                 removeClause(cs[i]);
             else
                 cs[j++] = cs[i];
+        }
     }
     cs.shrink(i - j);
 }
@@ -1662,7 +1729,7 @@
 {
     vec<Var> vs;
     for (Var v = 0; v < nVars(); v++)
-        if (decision[v] && value(v) == l_Undef)
+        if (decision[v] && value(v) == chrl_Undef)
             vs.push(v);
 
     order_heap_CHB  .build(vs);
@@ -1674,7 +1741,7 @@
 /*_________________________________________________________________________________________________
 |
 |  simplify : [void]  ->  [bool]
-|  
+|
 |  Description:
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
@@ -1691,8 +1758,8 @@
 
     // Remove satisfied clauses:
     removeSatisfied(learnts_core); // Should clean core first.
-    safeRemoveSatisfied(learnts_tier2, TIER2);
-    safeRemoveSatisfied(learnts_local, LOCAL);
+    safeRemoveSatisfied(learnts_tier2, MAPLECHRONO_TIER2);
+    safeRemoveSatisfied(learnts_local, MAPLECHRONO_LOCAL);
     if (remove_satisfied)        // Can be turned off.
         removeSatisfied(clauses);
     checkGarbage();
@@ -1737,10 +1804,10 @@
                 Clause& rc=ca[reason(v)];
                 int reasonVarLevel=var_iLevel_tmp[v]+1;
                 if(reasonVarLevel>max_level) max_level=reasonVarLevel;
-                if (rc.size()==2 && value(rc[0])==l_False) {
+                if (rc.size()==2 && value(rc[0])==chrl_False) {
                     // Special case for binary clauses
                     // The first one has to be SAT
-                    assert(value(rc[1]) != l_False);
+                    assert(value(rc[1]) != chrl_False);
                     Lit tmp = rc[0];
                     rc[0] =  rc[1], rc[1] = tmp;
                 }
@@ -1811,7 +1878,7 @@
 
     for(i=lits.size()-1; i>=0; i--) {
         lit=lits[i];
-        if (value(lit) == l_Undef) {
+        if (value(lit) == chrl_Undef) {
             newDecisionLevel();
             uncheckedEnqueue(lit);
             CRef confl = propagate();
@@ -1825,14 +1892,14 @@
 /*_________________________________________________________________________________________________
 |
 |  search : (nof_conflicts : int) (params : const SearchParams&)  ->  [lbool]
-|  
+|
 |  Description:
-|    Search for a model the specified number of conflicts. 
-|  
+|    Search for a model the specified number of conflicts.
+|
 |  Output:
-|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
-|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
-|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
+|    'chrl_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+|    all variables are decision variables, this means that the clause set is satisfiable. 'chrl_False'
+|    if the clause set is unsatisfiable. 'chrl_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
 lbool Solver::search(int& nof_conflicts)
 {
@@ -1852,7 +1919,7 @@
         //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
         nbSimplifyAll++;
         if (!simplifyAll()){
-            return l_False;
+            return chrl_False;
         }
         curSimplify = (conflicts / nbconfbeforesimplify) + 1;
         nbconfbeforesimplify += incSimplify;
@@ -1871,13 +1938,13 @@
             conflicts++; nof_conflicts--;
             if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             ConflictData data = FindConflictLevel(confl);
-            if (data.nHighestLevel == 0) return l_False;
+            if (data.nHighestLevel == 0) return chrl_False;
             if (data.bOnlyOneLitFromHighest)
             {
 				cancelUntil(data.nHighestLevel - 1);
 				continue;
 			}
-			
+
             learnt_clause.clear();
             if(conflicts>50000) DISTANCE=0;
             else DISTANCE=1;
@@ -1911,10 +1978,10 @@
                 ca[cr].set_lbd(lbd);
                 if (lbd <= core_lbd_cut){
                     learnts_core.push(cr);
-                    ca[cr].mark(CORE);
+                    ca[cr].mark(MAPLECHRONO_CORE);
                 }else if (lbd <= 6){
                     learnts_tier2.push(cr);
-                    ca[cr].mark(TIER2);
+                    ca[cr].mark(MAPLECHRONO_TIER2);
                     ca[cr].touched() = conflicts;
                 }else{
                     learnts_local.push(cr);
@@ -1922,17 +1989,17 @@
                 attachClause(cr);
 
                 uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
-#ifdef PRINT_OUT
+#ifdef MAPLECHRONO_PRINT_OUT
                 std::cout << "new " << ca[cr] << "\n";
                 std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
-#endif                
+#endif
             }
             if (drup_file){
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
                 binDRUP('a', learnt_clause, drup_file);
 #else
                 for (int i = 0; i < learnt_clause.size(); i++)
-                    fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
+                    fprintf(drup_file, "%i ", var(learnt_clause[i]) * (-2 * sign(learnt_clause[i]) + 1));
                 fprintf(drup_file, "0\n");
 #endif
             }
@@ -1961,17 +2028,17 @@
                 restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
                 cached = true;
             }
-            if (restart /*|| !withinBudget()*/){
+            if (restart || !withinBudget()){
                 lbd_queue.clear();
                 cached = false;
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
                 cancelUntil(0);
-                return l_Undef; }
+                return chrl_Undef; }
 
             // Simplify the set of problem clauses:
             if (decisionLevel() == 0 && !simplify())
-                return l_False;
+                return chrl_False;
 
             if (conflicts >= next_T2_reduce){
                 next_T2_reduce = conflicts + 10000;
@@ -1981,37 +2048,37 @@
                 reduceDB(); }
 
             Lit next = lit_Undef;
-            /*while (decisionLevel() < assumptions.size()){
+            while (decisionLevel() < assumptions.size()){
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if (value(p) == l_True){
+                if (value(p) == chrl_True){
                     // Dummy decision level:
                     newDecisionLevel();
-                }else if (value(p) == l_False){
+                }else if (value(p) == chrl_False){
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return chrl_False;
                 }else{
                     next = p;
                     break;
                 }
             }
 
-            if (next == lit_Undef)*/{
+            if (next == lit_Undef){
                 // New variable decision:
                 decisions++;
                 next = pickBranchLit();
 
                 if (next == lit_Undef)
                     // Model found:
-                    return l_True;
+                    return chrl_True;
             }
 
             // Increase decision level and enqueue 'next'
             newDecisionLevel();
             uncheckedEnqueue(next, decisionLevel());
-#ifdef PRINT_OUT            
+#ifdef MAPLECHRONO_PRINT_OUT
             std::cout << "d " << next << " l " << decisionLevel() << "\n";
-#endif            
+#endif
         }
     }
 }
@@ -2070,14 +2137,14 @@
 
     model.clear();
     conflict.clear();
-    if (!ok) return l_False;
+    if (!ok) return chrl_False;
 
     solves++;
 
     max_learnts               = nClauses() * learntsize_factor;
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
     learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
-    lbool   status            = l_Undef;
+    lbool   status            = chrl_Undef;
 
     if (verbosity >= 1){
         printf("c ============================[ Search Statistics ]==============================\n");
@@ -2090,46 +2157,51 @@
 
     VSIDS = true;
     int init = 10000;
-    while (status == l_Undef && init > 0 /*&& withinBudget()*/)
+    while (status == chrl_Undef && init > 0 && withinBudget())
         status = search(init);
-    VSIDS = false;
 
-    // Search:
-    int curr_restarts = 0;
-    while (status == l_Undef /*&& withinBudget()*/){
-        if (VSIDS){
-            int weighted = INT32_MAX;
-            status = search(weighted);
-        }else{
-            int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
-            curr_restarts++;
-            status = search(nof_conflicts);
-        }
-        if (!VSIDS && switch_mode){
-            VSIDS = true;
-            printf("c Switched to VSIDS.\n");
-            fflush(stdout);
-            picked.clear();
-            conflicted.clear();
-            almost_conflicted.clear();
-#ifdef ANTI_EXPLORATION
-            canceled.clear();
+    if (status == chrl_Undef) {
+        VSIDS = false;
+
+        // Search:
+        int curr_restarts = 0;
+        while (status == chrl_Undef && withinBudget()){
+            if (VSIDS){
+                int weighted = INT32_MAX;
+                status = search(weighted);
+            }else{
+                int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
+                curr_restarts++;
+                status = search(nof_conflicts);
+            }
+            if (!VSIDS && switch_mode){
+                VSIDS = true;
+                // printf("c Switched to VSIDS.\n");
+                fflush(stdout);
+                picked.clear();
+                conflicted.clear();
+                almost_conflicted.clear();
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
+                canceled.clear();
 #endif
+            }
         }
     }
 
     if (verbosity >= 1)
         printf("c ===============================================================================\n");
 
-#ifdef BIN_DRUP
-    if (drup_file && status == l_False) binDRUP_flush(drup_file);
+#ifdef MAPLECHRONO_BIN_DRUP
+    if (drup_file && status == chrl_False) binDRUP_flush(drup_file);
+#else
+    if (drup_file && status == chrl_False) fprintf(drup_file, "0\n");
 #endif
 
-    if (status == l_True){
+    if (status == chrl_True){
         // Extend & copy model:
         model.growTo(nVars());
         for (int i = 0; i < nVars(); i++) model[i] = value(i);
-    }else if (status == l_False && conflict.size() == 0)
+    }else if (status == chrl_False && conflict.size() == 0)
         ok = false;
 
     cancelUntil(0);
@@ -2138,7 +2210,7 @@
 
 //=================================================================================================
 // Writing CNF to DIMACS:
-// 
+//
 // FIXME: this needs to be rewritten completely.
 
 static Var mapVar(Var x, vec<Var>& map, Var& max)
@@ -2156,7 +2228,7 @@
     if (satisfied(c)) return;
 
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) != l_False)
+        if (value(c[i]) != chrl_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
     fprintf(f, "0\n");
 }
@@ -2192,7 +2264,7 @@
         if (!satisfied(ca[clauses[i]])){
             Clause& c = ca[clauses[i]];
             for (int j = 0; j < c.size(); j++)
-                if (value(c[j]) != l_False)
+                if (value(c[j]) != chrl_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -2202,7 +2274,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for (int i = 0; i < assumptions.size(); i++){
-        assert(value(assumptions[i]) != l_False);
+        assert(value(assumptions[i]) != chrl_False);
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max)+1);
     }
 
diff -Naur solvers/maplechrono/core/Solver.h solvers/chrono/core/Solver.h
--- solvers/maplechrono/core/Solver.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/core/Solver.h	2019-03-16 23:11:34.000000000 +0000
@@ -3,13 +3,13 @@
            Copyright (c) 2007-2010, Niklas Sorensson
 
 Chanseok Oh's MiniSat Patch Series -- Copyright (c) 2015, Chanseok Oh
- 
+
 Maple_LCM, Based on MapleCOMSPS_DRUP -- Copyright (c) 2017, Mao Luo, Chu-Min LI, Fan Xiao: implementing a learnt clause minimisation approach
 Reference: M. Luo, C.-M. Li, F. Xiao, F. Manya, and Z. L. , “An effective learnt clause minimization approach for cdcl sat solvers,” in IJCAI-2017, 2017, pp. to–appear.
- 
+
 Maple_LCM_Dist, Based on Maple_LCM -- Copyright (c) 2017, Fan Xiao, Chu-Min LI, Mao Luo: using a new branching heuristic called Distance at the beginning of search
- 
- 
+
+
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute,
@@ -26,34 +26,34 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Solver_h
-#define Minisat_Solver_h
+#ifndef MapleChrono_Solver_h
+#define MapleChrono_Solver_h
 
-#define ANTI_EXPLORATION
-#define BIN_DRUP
+#define MAPLECHRONO_ANTI_EXPLORATION
+// #define MAPLECHRONO_BIN_DRUP
 
-#define GLUCOSE23
-//#define INT_QUEUE_AVG
-//#define LOOSE_PROP_STAT
-
-#ifdef GLUCOSE23
-#define INT_QUEUE_AVG
-#define LOOSE_PROP_STAT
+#define MAPLECHRONO_GLUCOSE23
+//#define MAPLECHRONO_INT_QUEUE_AVG
+//#define MAPLECHRONO_LOOSE_PROP_STAT
+
+#ifdef MAPLECHRONO_GLUCOSE23
+#define MAPLECHRONO_INT_QUEUE_AVG
+#define MAPLECHRONO_LOOSE_PROP_STAT
 #endif
 
-#include "mtl/Vec.h"
-#include "mtl/Heap.h"
-#include "mtl/Alg.h"
-#include "utils/Options.h"
-#include "core/SolverTypes.h"
+#include "maplechrono/mtl/Vec.h"
+#include "maplechrono/mtl/Heap.h"
+#include "maplechrono/mtl/Alg.h"
+#include "maplechrono/utils/Options.h"
+#include "maplechrono/core/SolverTypes.h"
 
 
 // Don't change the actual numbers.
-#define LOCAL 0
-#define TIER2 2
-#define CORE  3
+#define MAPLECHRONO_LOCAL 0
+#define MAPLECHRONO_TIER2 2
+#define MAPLECHRONO_CORE  3
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Solver -- the main class:
@@ -69,7 +69,7 @@
     public:
         MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
         inline bool   full () const { return q_sz == max_sz; }
-#ifdef INT_QUEUE_AVG
+#ifdef MAPLECHRONO_INT_QUEUE_AVG
         inline T      avg  () const { assert(full()); return sum / max_sz; }
 #else
         inline double avg  () const { assert(full()); return sum / (double) max_sz; }
@@ -113,6 +113,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
     void    toDimacs     (const char *file, const vec<Lit>& assumps);
@@ -123,7 +124,7 @@
     void    toDimacs     (const char* file, Lit p);
     void    toDimacs     (const char* file, Lit p, Lit q);
     void    toDimacs     (const char* file, Lit p, Lit q, Lit r);
-    
+
     // Variable mode:
     //
     void    setPolarity    (Var v, bool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
@@ -163,7 +164,8 @@
 
     // Mode of operation:
     //
-    FILE*     drup_file;
+    FILE     *drup_file;
+    void     *drup_pyfile;
     int       verbosity;
     double    step_size;
     double    step_size_dec;
@@ -197,7 +199,7 @@
     vec<uint32_t> picked;
     vec<uint32_t> conflicted;
     vec<uint32_t> almost_conflicted;
-#ifdef ANTI_EXPLORATION
+#ifdef MAPLECHRONO_ANTI_EXPLORATION
     vec<uint32_t> canceled;
 #endif
 
@@ -228,7 +230,7 @@
         bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
         VarOrderLt(const vec<double>&  act) : activity(act) { }
     };
-    
+
     struct ConflictData
 	{
 		ConflictData() :
@@ -277,7 +279,7 @@
     next_L_reduce;
 
     ClauseAllocator     ca;
-    
+
     int 				confl_to_chrono;
     int 				chrono;
 
@@ -346,9 +348,9 @@
     int      decisionLevel    ()      const; // Gives the current decisionlevel.
     uint32_t abstractLevel    (Var x) const; // Used to represent an abstraction of sets of decision levels.
     CRef     reason           (Var x) const;
-    
+
     ConflictData FindConflictLevel(CRef cind);
-    
+
 public:
     int      level            (Var x) const;
 protected:
@@ -368,7 +370,7 @@
         return lbd;
     }
 
-#ifdef BIN_DRUP
+#ifdef MAPLECHRONO_BIN_DRUP
     static int buf_len;
     static unsigned char drup_buf[];
     static unsigned char* buf_ptr;
@@ -376,7 +378,7 @@
     static inline void byteDRUP(Lit l){
         unsigned int u = 2 * (var(l) + 1) + sign(l);
         do{
-            *buf_ptr++ = u & 0x7f | 0x80; buf_len++;
+            *buf_ptr++ = (u & 0x7f) | 0x80; buf_len++;
             u = u >> 7;
         }while (u);
         *(buf_ptr - 1) &= 0x7f; // End marker of this unsigned number.
@@ -400,8 +402,8 @@
     }
 
     static inline void binDRUP_flush(FILE* drup_file){
-//        fwrite(drup_buf, sizeof(unsigned char), buf_len, drup_file);
-        fwrite_unlocked(drup_buf, sizeof(unsigned char), buf_len, drup_file);
+        fwrite(drup_buf, sizeof(unsigned char), buf_len, drup_file);
+        // fwrite_unlocked(drup_buf, sizeof(unsigned char), buf_len, drup_file);
         buf_ptr = drup_buf; buf_len = 0;
     }
 #endif
@@ -501,15 +503,15 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != chrl_Undef ? value(p) != chrl_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
 inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
 inline bool     Solver::locked          (const Clause& c) const {
-    int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
-    return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
+    int i = c.size() != 2 ? 0 : (value(c[0]) == chrl_True ? 0 : 1);
+    return value(c[i]) == chrl_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
 }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
@@ -525,8 +527,8 @@
 inline int      Solver::nVars         ()      const   { return vardata.size(); }
 inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
 inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
-inline void     Solver::setDecisionVar(Var v, bool b) 
-{ 
+inline void     Solver::setDecisionVar(Var v, bool b)
+{
     if      ( b && !decision[v]) dec_vars++;
     else if (!b &&  decision[v]) dec_vars--;
 
@@ -549,11 +551,11 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == chrl_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == chrl_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == chrl_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == chrl_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == chrl_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
diff -Naur solvers/maplechrono/core/SolverTypes.h solvers/chrono/core/SolverTypes.h
--- solvers/maplechrono/core/SolverTypes.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/core/SolverTypes.h	2019-03-16 21:16:54.000000000 +0000
@@ -1,15 +1,15 @@
 /***********************************************************************************[SolverTypes.h]
 MiniSat -- Copyright (c) 2003-2006, Niklas Een, Niklas Sorensson
            Copyright (c) 2007-2010, Niklas Sorensson
- 
+
 Chanseok Oh's MiniSat Patch Series -- Copyright (c) 2015, Chanseok Oh
 
 Maple_LCM, Based on MapleCOMSPS_DRUP -- Copyright (c) 2017, Mao Luo, Chu-Min LI, Fan Xiao: implementing a learnt clause minimisation approach
 Reference: M. Luo, C.-M. Li, F. Xiao, F. Manya, and Z. L. , “An effective learnt clause minimization approach for cdcl sat solvers,” in IJCAI-2017, 2017, pp. to–appear.
- 
+
 Maple_LCM_Dist, Based on Maple_LCM -- Copyright (c) 2017, Fan Xiao, Chu-Min LI, Mao Luo: using a new branching heuristic called Distance at the beginning of search
- 
- 
+
+
 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute,
@@ -27,19 +27,19 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_SolverTypes_h
-#define Minisat_SolverTypes_h
+#ifndef MapleChrono_SolverTypes_h
+#define MapleChrono_SolverTypes_h
 
 #include <assert.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Alg.h"
-#include "mtl/Vec.h"
-#include "mtl/Map.h"
-#include "mtl/Alloc.h"
+#include "maplechrono/mtl/IntTypes.h"
+#include "maplechrono/mtl/Alg.h"
+#include "maplechrono/mtl/Vec.h"
+#include "maplechrono/mtl/Map.h"
+#include "maplechrono/mtl/Alloc.h"
 #include <iostream>
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -70,9 +70,9 @@
 inline  int  var       (Lit p)              { return p.x >> 1; }
 
 // Mapping Literals to and from compact integers suitable for array indexing:
-inline  int  toInt     (Var v)              { return v; } 
-inline  int  toInt     (Lit p)              { return p.x; } 
-inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
+inline  int  toInt     (Var v)              { return v; }
+inline  int  toInt     (Lit p)              { return p.x; }
+inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; }
 
 //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
 //const Lit lit_Error = mkLit(var_Undef, true );  // }
@@ -80,7 +80,7 @@
 const Lit lit_Undef = { -2 };  // }- Useful special constants.
 const Lit lit_Error = { -1 };  // }
 
-inline std::ostream& operator<<(std::ostream& out, const Lit& val) 
+inline std::ostream& operator<<(std::ostream& out, const Lit& val)
 {
     out << (sign(val) ? -var(val) : var(val)) << std::flush;
     return out;
@@ -92,13 +92,13 @@
 // Lifted booleans:
 //
 // NOTE: this implementation is optimized for the case when comparisons between values are mostly
-//       between one variable and one constant. Some care had to be taken to make sure that gcc 
+//       between one variable and one constant. Some care had to be taken to make sure that gcc
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (lbool((uint8_t)1))
-#define l_Undef (lbool((uint8_t)2))
+#define chrl_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+#define chrl_False (lbool((uint8_t)1))
+#define chrl_Undef (lbool((uint8_t)2))
 
 class lbool {
     uint8_t value;
@@ -270,12 +270,12 @@
     void reloc(CRef& cr, ClauseAllocator& to)
     {
         Clause& c = operator[](cr);
-        
+
         if (c.reloced()) { cr = c.relocation(); return; }
-        
+
         cr = to.alloc(c, c.learnt());
         c.relocate(cr);
-        
+
         // Copy extra data-fields:
         // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
         to[cr].mark(c.mark());
@@ -293,13 +293,13 @@
 };
 
 
-inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
+inline std::ostream& operator<<(std::ostream& out, const Clause& cls)
 {
     for (int i = 0; i < cls.size(); ++i)
     {
 		out << cls[i] << " ";
 	}
-	
+
     return out;
 }
 
@@ -316,7 +316,7 @@
 
 public:
     OccLists(const Deleted& d) : deleted(d) {}
-    
+
     void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
     // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
     Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
@@ -381,7 +381,7 @@
     void     clear       ()                           { map.clear(); }
     int      size        ()                const      { return map.elems(); }
 
-    
+
     // Insert/Remove/Test mapping:
     void     insert      (CRef cr, const T& t){ map.insert(cr, t); }
     void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } // NOTE: for compatibility
@@ -408,11 +408,11 @@
 /*_________________________________________________________________________________________________
 |
 |  subsumes : (other : const Clause&)  ->  Lit
-|  
+|
 |  Description:
 |       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
 |       by subsumption resolution.
-|  
+|
 |    Result:
 |       lit_Error  - No subsumption or simplification
 |       lit_Undef  - Clause subsumes 'other'
diff -Naur solvers/maplechrono/mtl/Alg.h solvers/chrono/mtl/Alg.h
--- solvers/maplechrono/mtl/Alg.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Alg.h	2019-03-16 10:06:28.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Alg_h
-#define Minisat_Alg_h
+#ifndef MapleChrono_Alg_h
+#define MapleChrono_Alg_h
 
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/Vec.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur solvers/maplechrono/mtl/Alloc.h solvers/chrono/mtl/Alloc.h
--- solvers/maplechrono/mtl/Alloc.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Alloc.h	2019-03-16 10:06:38.000000000 +0000
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_Alloc_h
-#define Minisat_Alloc_h
+#ifndef MapleChrono_Alloc_h
+#define MapleChrono_Alloc_h
 
-#include "mtl/XAlloc.h"
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/XAlloc.h"
+#include "maplechrono/mtl/Vec.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
@@ -56,7 +56,7 @@
     uint32_t size      () const      { return sz; }
     uint32_t wasted    () const      { return wasted_; }
 
-    Ref      alloc     (int size); 
+    Ref      alloc     (int size);
     void     free      (int size)    { wasted_ += size; }
 
     // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
@@ -109,14 +109,14 @@
 template<class T>
 typename RegionAllocator<T>::Ref
 RegionAllocator<T>::alloc(int size)
-{ 
+{
     // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
     assert(size > 0);
     capacity(sz + size);
 
     uint32_t prev_sz = sz;
     sz += size;
-    
+
     // Handle overflow:
     if (sz < prev_sz)
         throw OutOfMemoryException();
diff -Naur solvers/maplechrono/mtl/Heap.h solvers/chrono/mtl/Heap.h
--- solvers/maplechrono/mtl/Heap.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Heap.h	2019-03-16 10:07:08.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Heap_h
-#define Minisat_Heap_h
+#ifndef MapleChrono_Heap_h
+#define MapleChrono_Heap_h
 
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/Vec.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
@@ -45,7 +45,7 @@
     {
         int x  = heap[i];
         int p  = parent(i);
-        
+
         while (i != 0 && lt(x, heap[p])){
             heap[i]          = heap[p];
             indices[heap[p]] = i;
@@ -103,7 +103,7 @@
 
         indices[n] = heap.size();
         heap.push(n);
-        percolateUp(indices[n]); 
+        percolateUp(indices[n]);
     }
 
 
@@ -115,7 +115,7 @@
         indices[x]       = -1;
         heap.pop();
         if (heap.size() > 1) percolateDown(0);
-        return x; 
+        return x;
     }
 
 
@@ -133,11 +133,11 @@
             percolateDown(i);
     }
 
-    void clear(bool dealloc = false) 
-    { 
+    void clear(bool dealloc = false)
+    {
         for (int i = 0; i < heap.size(); i++)
             indices[heap[i]] = -1;
-        heap.clear(dealloc); 
+        heap.clear(dealloc);
     }
 };
 
diff -Naur solvers/maplechrono/mtl/IntTypes.h solvers/chrono/mtl/IntTypes.h
--- solvers/maplechrono/mtl/IntTypes.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/IntTypes.h	2019-03-16 10:07:28.000000000 +0000
@@ -17,8 +17,8 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_IntTypes_h
-#define Minisat_IntTypes_h
+#ifndef MapleChrono_IntTypes_h
+#define MapleChrono_IntTypes_h
 
 #ifdef __sun
     // Not sure if there are newer versions that support C99 headers. The
diff -Naur solvers/maplechrono/mtl/Map.h solvers/chrono/mtl/Map.h
--- solvers/maplechrono/mtl/Map.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Map.h	2019-03-16 10:07:56.000000000 +0000
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Map_h
-#define Minisat_Map_h
+#ifndef MapleChrono_Map_h
+#define MapleChrono_Map_h
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/IntTypes.h"
+#include "maplechrono/mtl/Vec.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Default hash/equals functions
@@ -72,7 +72,7 @@
     bool    checkCap(int new_size) const { return new_size > cap; }
 
     int32_t index  (const K& k) const { return hash(k) % cap; }
-    void   _insert (const K& k, const D& d) { 
+    void   _insert (const K& k, const D& d) {
         vec<Pair>& ps = table[index(k)];
         ps.push(); ps.last().key = k; ps.last().data = d; }
 
@@ -96,7 +96,7 @@
         // printf(" --- rehashing, old-cap=%d, new-cap=%d\n", cap, newsize);
     }
 
-    
+
  public:
 
     Map () : table(NULL), cap(0), size(0) {}
@@ -137,7 +137,7 @@
         for (int i = 0; i < ps.size(); i++)
             if (equals(ps[i].key, k)){
                 d = ps[i].data;
-                return true; } 
+                return true; }
         return false;
     }
 
diff -Naur solvers/maplechrono/mtl/Queue.h solvers/chrono/mtl/Queue.h
--- solvers/maplechrono/mtl/Queue.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Queue.h	2019-03-16 10:08:41.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Queue_h
-#define Minisat_Queue_h
+#ifndef MapleChrono_Queue_h
+#define MapleChrono_Queue_h
 
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/Vec.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 
diff -Naur solvers/maplechrono/mtl/Sort.h solvers/chrono/mtl/Sort.h
--- solvers/maplechrono/mtl/Sort.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Sort.h	2019-03-16 10:09:06.000000000 +0000
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Sort_h
-#define Minisat_Sort_h
+#ifndef MapleChrono_Sort_h
+#define MapleChrono_Sort_h
 
-#include "mtl/Vec.h"
+#include "maplechrono/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Minisat {
+namespace MapleChrono {
 
 template<class T>
 struct LessThan_default {
diff -Naur solvers/maplechrono/mtl/Vec.h solvers/chrono/mtl/Vec.h
--- solvers/maplechrono/mtl/Vec.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/Vec.h	2019-03-16 10:32:13.000000000 +0000
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Vec_h
-#define Minisat_Vec_h
+#ifndef MapleChrono_Vec_h
+#define MapleChrono_Vec_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "maplechrono/mtl/IntTypes.h"
+#include "maplechrono/mtl/XAlloc.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Automatically resizable arrays
@@ -43,7 +43,7 @@
     // Don't allow copying (error prone):
     vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              vec        (vec<T>& other) { assert(0); }
-             
+
     // Helpers for calculating next capacity:
     static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
     //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
@@ -96,7 +96,7 @@
 void vec<T>::capacity(int min_cap) {
     if (cap >= min_cap) return;
     int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
-    if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
+    if (add > INT_MAX - cap || (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM))
         throw OutOfMemoryException();
  }
 
diff -Naur solvers/maplechrono/mtl/XAlloc.h solvers/chrono/mtl/XAlloc.h
--- solvers/maplechrono/mtl/XAlloc.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/mtl/XAlloc.h	2019-03-16 10:09:45.000000000 +0000
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_XAlloc_h
-#define Minisat_XAlloc_h
+#ifndef MapleChrono_XAlloc_h
+#define MapleChrono_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 
-namespace Minisat {
+namespace MapleChrono {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur solvers/maplechrono/utils/Options.cc solvers/chrono/utils/Options.cc
--- solvers/maplechrono/utils/Options.cc	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/utils/Options.cc	2019-03-16 11:54:41.000000000 +0000
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "mtl/Sort.h"
-#include "utils/Options.h"
-#include "utils/ParseUtils.h"
+#include "maplechrono/mtl/Sort.h"
+#include "maplechrono/utils/Options.h"
+#include "maplechrono/utils/ParseUtils.h"
 
-using namespace Minisat;
+using namespace MapleChrono;
 
-void Minisat::parseOptions(int& argc, char** argv, bool strict)
+void MapleChrono::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -35,18 +35,19 @@
                 printUsageAndExit(argc, argv, true);
         } else {
             bool parsed_ok = false;
-        
+
             for (int k = 0; !parsed_ok && k < Option::getOptionList().size(); k++){
                 parsed_ok = Option::getOptionList()[k]->parse(argv[i]);
 
                 // fprintf(stderr, "checking %d: %s against flag <%s> (%s)\n", i, argv[i], Option::getOptionList()[k]->name, parsed_ok ? "ok" : "skip");
             }
 
-            if (!parsed_ok)
+            if (!parsed_ok) {
                 if (strict && match(argv[i], "-"))
                     fprintf(stderr, "ERROR! Unknown flag \"%s\". Use '--%shelp' for help.\n", argv[i], Option::getHelpPrefixString()), exit(1);
                 else
                     argv[j++] = argv[i];
+            }
         }
     }
 
@@ -54,9 +55,9 @@
 }
 
 
-void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)
+void MapleChrono::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void MapleChrono::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void MapleChrono::printUsageAndExit (int argc, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
diff -Naur solvers/maplechrono/utils/Options.h solvers/chrono/utils/Options.h
--- solvers/maplechrono/utils/Options.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/utils/Options.h	2019-03-16 10:37:24.000000000 +0000
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Options_h
-#define Minisat_Options_h
+#ifndef MapleChrono_Options_h
+#define MapleChrono_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
-#include "utils/ParseUtils.h"
+#include "maplechrono/mtl/IntTypes.h"
+#include "maplechrono/mtl/Vec.h"
+#include "maplechrono/utils/ParseUtils.h"
 
-namespace Minisat {
+namespace MapleChrono {
 
 //==================================================================================================
 // Top-level option parse/help functions:
@@ -60,20 +60,20 @@
     struct OptionLt {
         bool operator()(const Option* x, const Option* y) {
             int test1 = strcmp(x->category, y->category);
-            return test1 < 0 || test1 == 0 && strcmp(x->type_name, y->type_name) < 0;
+            return test1 < 0 || (test1 == 0 && strcmp(x->type_name, y->type_name) < 0);
         }
     };
 
-    Option(const char* name_, 
+    Option(const char* name_,
            const char* desc_,
            const char* cate_,
-           const char* type_) : 
+           const char* type_) :
       name       (name_)
     , description(desc_)
     , category   (cate_)
     , type_name  (type_)
-    { 
-        getOptionList().push(this); 
+    {
+        getOptionList().push(this);
     }
 
  public:
@@ -135,7 +135,7 @@
     DoubleOption& operator=(double x)   { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -143,7 +143,7 @@
         char*  end;
         double tmp = strtod(span, &end);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp >= range.end && (!range.end_inclusive || tmp != range.end)){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -159,12 +159,12 @@
     }
 
     virtual void help (bool verbose = false){
-        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n", 
-                name, type_name, 
-                range.begin_inclusive ? '[' : '(', 
+        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n",
+                name, type_name,
+                range.begin_inclusive ? '[' : '(',
                 range.begin,
                 range.end,
-                range.end_inclusive ? ']' : ')', 
+                range.end_inclusive ? ']' : ')',
                 value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
@@ -187,13 +187,13 @@
  public:
     IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
         : Option(n, d, c, "<int32>"), range(r), value(def) {}
- 
+
     operator   int32_t   (void) const { return value; }
     operator   int32_t&  (void)       { return value; }
     IntOption& operator= (int32_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -201,7 +201,7 @@
         char*   end;
         int32_t tmp = strtol(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -249,13 +249,13 @@
  public:
     Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
         : Option(n, d, c, "<int64>"), range(r), value(def) {}
- 
+
     operator     int64_t   (void) const { return value; }
     operator     int64_t&  (void)       { return value; }
     Int64Option& operator= (int64_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -263,7 +263,7 @@
         char*   end;
         int64_t tmp = strtoll(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -282,15 +282,15 @@
         if (range.begin == INT64_MIN)
             fprintf(stderr, "imin");
         else
-            fprintf(stderr, "%4"PRIi64, range.begin);
+            fprintf(stderr, "%4" PRIi64, range.begin);
 
         fprintf(stderr, " .. ");
         if (range.end == INT64_MAX)
             fprintf(stderr, "imax");
         else
-            fprintf(stderr, "%4"PRIi64, range.end);
+            fprintf(stderr, "%4" PRIi64, range.end);
 
-        fprintf(stderr, "] (default: %"PRIi64")\n", value);
+        fprintf(stderr, "] (default: %" PRIi64")\n", value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
@@ -307,7 +307,7 @@
 {
     const char* value;
  public:
-    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) 
+    StringOption(const char* c, const char* n, const char* d, const char* def = NULL)
         : Option(n, d, c, "<string>"), value(def) {}
 
     operator      const char*  (void) const     { return value; }
@@ -315,7 +315,7 @@
     StringOption& operator=    (const char* x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -330,7 +330,7 @@
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
         }
-    }    
+    }
 };
 
 
@@ -343,7 +343,7 @@
     bool value;
 
  public:
-    BoolOption(const char* c, const char* n, const char* d, bool v) 
+    BoolOption(const char* c, const char* n, const char* d, bool v)
         : Option(n, d, c, "<bool>"), value(v) {}
 
     operator    bool     (void) const { return value; }
@@ -351,8 +351,8 @@
     BoolOption& operator=(bool b)     { value = b; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
-        
+        const char* span = str;
+
         if (match(span, "-")){
             bool b = !match(span, "no-");
 
diff -Naur solvers/maplechrono/utils/ParseUtils.h solvers/chrono/utils/ParseUtils.h
--- solvers/maplechrono/utils/ParseUtils.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/utils/ParseUtils.h	2019-03-16 10:05:07.000000000 +0000
@@ -18,15 +18,15 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_ParseUtils_h
-#define Minisat_ParseUtils_h
+#ifndef MapleChrono_ParseUtils_h
+#define MapleChrono_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
 
 #include <zlib.h>
 
-namespace Minisat {
+namespace MapleChrono {
 
 //-------------------------------------------------------------------------------------------------
 // A simple buffered character stream class:
@@ -104,7 +104,7 @@
 
     in += i;
 
-    return true; 
+    return true;
 }
 
 // String matching: consumes characters eagerly, but does not require random access iterator.
diff -Naur solvers/maplechrono/utils/System.cc solvers/chrono/utils/System.cc
--- solvers/maplechrono/utils/System.cc	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/utils/System.cc	2019-03-16 10:03:55.000000000 +0000
@@ -18,14 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "utils/System.h"
+#include "maplechrono/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdio.h>
 #include <stdlib.h>
 
-using namespace Minisat;
+using namespace MapleChrono;
 
 // TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
 // one for reading the current virtual memory size.
@@ -67,29 +67,29 @@
     return peak_kb;
 }
 
-double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Minisat::memUsedPeak() { 
+double MapleChrono::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double MapleChrono::memUsedPeak() {
     double peak = memReadPeak() / 1024;
     return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__)
 
-double Minisat::memUsed(void) {
+double MapleChrono::memUsed(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
-double MiniSat::memUsedPeak(void) { return memUsed(); }
+double MapleChrono::memUsedPeak(void) { return memUsed(); }
 
 
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Minisat::memUsed(void) {
+double MapleChrono::memUsed(void) {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
-double Minisat::memUsedPeak(void) {return memUsed(); }
+double MapleChrono::memUsedPeak(void) {return memUsed(); }
 #else
-double Minisat::memUsed() { 
+double MapleChrono::memUsed() {
     return 0; }
 #endif
diff -Naur solvers/maplechrono/utils/System.h solvers/chrono/utils/System.h
--- solvers/maplechrono/utils/System.h	2019-03-19 09:32:15.000000000 +0000
+++ solvers/chrono/utils/System.h	2019-03-16 10:04:33.000000000 +0000
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_System_h
-#define Minisat_System_h
+#ifndef MapleChrono_System_h
+#define MapleChrono_System_h
 
 #if defined(__linux__)
 #include <fpu_control.h>
 #endif
 
-#include "mtl/IntTypes.h"
+#include "maplechrono/mtl/IntTypes.h"
 
 //-------------------------------------------------------------------------------------------------
 
-namespace Minisat {
+namespace MapleChrono {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 extern double memUsed();            // Memory in mega bytes (returns 0 for unsupported architectures).
@@ -43,14 +43,14 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Minisat::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double MapleChrono::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Minisat::cpuTime(void) {
+static inline double MapleChrono::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
