diff -Naur solvers/maplesat/Makefile solvers/maple/Makefile
--- solvers/maplesat/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ solvers/maple/Makefile	2019-03-17 23:08:19.000000000 +0000
@@ -0,0 +1,39 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  maplesat
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
+
+#-------------------------------------------------------------------------------
diff -Naur solvers/maplesat/core/Solver.cc solvers/maple/core/Solver.cc
--- solvers/maplesat/core/Solver.cc	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/core/Solver.cc	2019-03-18 22:33:07.000000000 +0000
@@ -22,12 +22,12 @@
 
 #include <math.h>
 
-#include "mtl/Sort.h"
-#include "core/Solver.h"
+#include "maplesat/mtl/Sort.h"
+#include "maplesat/core/Solver.h"
 
-using namespace Minisat;
+using namespace Maplesat;
 
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
 int Solver::buf_len = 0;
 unsigned char Solver::drup_buf[2 * 1024 * 1024];
 unsigned char* Solver::buf_ptr = drup_buf;
@@ -62,6 +62,7 @@
     // Parameters (user settable):
     //
     drup_file        (NULL)
+  , drup_pyfile      (NULL)
   , verbosity        (0)
   , step_size        (opt_step_size)
   , step_size_dec    (opt_step_size_dec)
@@ -109,7 +110,7 @@
   , lbd_queue          (50)
   , next_T2_reduce     (10000)
   , next_L_reduce      (15000)
-  
+
   , counter            (0)
 
     // Resource constraints:
@@ -139,7 +140,7 @@
     watches_bin.init(mkLit(v, true ));
     watches  .init(mkLit(v, false));
     watches  .init(mkLit(v, true ));
-    assigns  .push(l_Undef);
+    assigns  .push(mpl_Undef);
     vardata  .push(mkVarData(CRef_Undef, 0));
     activity_no_r  .push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
     activity_glue_r.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
@@ -182,14 +183,14 @@
         for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
 
     for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if (value(ps[i]) == l_True || ps[i] == ~p)
+        if (value(ps[i]) == mpl_True || ps[i] == ~p)
             return true;
-        else if (value(ps[i]) != l_False && ps[i] != p)
+        else if (value(ps[i]) != mpl_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
     if (drup_file && i != j){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
         binDRUP('a', ps, drup_file);
         binDRUP('d', add_oc, drup_file);
 #else
@@ -233,7 +234,7 @@
     const Clause& c = ca[cr];
     assert(c.size() > 1);
     OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
-    
+
     if (strict){
         remove(ws[~c[0]], Watcher(cr, c[1]));
         remove(ws[~c[1]], Watcher(cr, c[0]));
@@ -252,7 +253,7 @@
 
     if (drup_file){
         if (c.mark() != 1){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
             binDRUP('d', c, drup_file);
 #else
             fprintf(drup_file, "d ");
@@ -267,16 +268,16 @@
     detachClause(cr);
     // Don't leave pointers to free'd memory!
     if (locked(c)){
-        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
+        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == mpl_True ? c[0] : c[1]);
         vardata[var(implied)].reason = CRef_Undef; }
-    c.mark(1); 
+    c.mark(1);
     ca.free(cr);
 }
 
 
 bool Solver::satisfied(const Clause& c) const {
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) == l_True)
+        if (value(c[i]) == mpl_True)
             return true;
     return false; }
 
@@ -303,8 +304,8 @@
                 }
             }
 
-            assigns [x] = l_Undef;
-            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
+            assigns [x] = mpl_Undef;
+            if (phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last()))
                 polarity[x] = sign(trail[c]);
             insertVarOrder(x); }
         qhead = trail_lim[level];
@@ -325,11 +326,11 @@
     // Random decision:
     /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
         next = order_heap[irand(random_seed,order_heap.size())];
-        if (value(next) == l_Undef && decision[next])
+        if (value(next) == mpl_Undef && decision[next])
             rnd_decisions++; }*/
 
     // Activity based decision:
-    while (next == var_Undef || value(next) != l_Undef || !decision[next])
+    while (next == var_Undef || value(next) != mpl_Undef || !decision[next])
         if (order_heap.empty())
             return lit_Undef;
         else
@@ -342,19 +343,19 @@
 /*_________________________________________________________________________________________________
 |
 |  analyze : (confl : Clause*) (out_learnt : vec<Lit>&) (out_btlevel : int&)  ->  [void]
-|  
+|
 |  Description:
 |    Analyze conflict and produce a reason clause.
-|  
+|
 |    Pre-conditions:
 |      * 'out_learnt' is assumed to be cleared.
 |      * Current decision level must be greater than root level.
-|  
+|
 |    Post-conditions:
 |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
-|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
+|      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the
 |        rest of literals. There may be others from the same level though.
-|  
+|
 |________________________________________________________________________________________________@*/
 void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
 {
@@ -371,30 +372,30 @@
         Clause& c = ca[confl];
 
         // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
-        if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
-            assert(value(c[1]) == l_True);
+        if (p != lit_Undef && c.size() == 2 && value(c[0]) == mpl_False){
+            assert(value(c[1]) == mpl_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp; }
 
         // Update LBD if improved.
-        if (c.learnt() && c.mark() != CORE){
+        if (c.learnt() && c.mark() != MAPLESAT_CORE){
             int lbd = computeLBD(c);
             if (lbd < c.lbd()){
                 if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
                 c.set_lbd(lbd);
                 if (lbd <= core_lbd_cut){
                     learnts_core.push(confl);
-                    c.mark(CORE);
-                }else if (lbd <= 6 && c.mark() == LOCAL){
-                    // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
-                    // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
+                    c.mark(MAPLESAT_CORE);
+                }else if (lbd <= 6 && c.mark() == MAPLESAT_LOCAL){
+                    // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from MAPLESAT_TIER2
+                    // to MAPLESAT_LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
                     learnts_tier2.push(confl);
-                    c.mark(TIER2); }
+                    c.mark(MAPLESAT_TIER2); }
             }
 
-            if (c.mark() == TIER2)
+            if (c.mark() == MAPLESAT_TIER2)
                 c.touched() = conflicts;
-            else if (c.mark() == LOCAL)
+            else if (c.mark() == MAPLESAT_LOCAL)
                 claBumpActivity(c);
         }
 
@@ -412,7 +413,7 @@
                     out_learnt.push(q);
             }
         }
-        
+
         // Select next clause to look at:
         while (!seen[var(trail[index--])]);
         p     = trail[index+1];
@@ -435,7 +436,7 @@
         for (i = j = 1; i < out_learnt.size(); i++)
             if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
                 out_learnt[j++] = out_learnt[i];
-        
+
     }else if (ccmin_mode == 1){
         for (i = j = 1; i < out_learnt.size(); i++){
             Var x = var(out_learnt[i]);
@@ -511,7 +512,7 @@
     for (int i = 0; i < ws.size(); i++){
         Lit the_other = ws[i].blocker;
         // Does 'the_other' appear negatively in 'out_learnt'?
-        if (seen2[var(the_other)] == counter && value(the_other) == l_True){
+        if (seen2[var(the_other)] == counter && value(the_other) == mpl_True){
             to_remove++;
             seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
         }
@@ -540,8 +541,8 @@
         Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
 
         // Special handling for binary clauses like in 'analyze()'.
-        if (c.size() == 2 && value(c[0]) == l_False){
-            assert(value(c[1]) == l_True);
+        if (c.size() == 2 && value(c[0]) == mpl_False){
+            assert(value(c[1]) == mpl_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp; }
 
@@ -569,7 +570,7 @@
 /*_________________________________________________________________________________________________
 |
 |  analyzeFinal : (p : Lit)  ->  [void]
-|  
+|
 |  Description:
 |    Specialized analysis procedure to express the final conflict in terms of assumptions.
 |    Calculates the (possibly empty) set of assumptions that led to the assignment of 'p', and
@@ -607,7 +608,7 @@
 
 void Solver::uncheckedEnqueue(Lit p, CRef from)
 {
-    assert(value(p) == l_Undef);
+    assert(value(p) == mpl_Undef);
     Var x = var(p);
 
     picked[x] = conflicts;
@@ -620,14 +621,67 @@
 }
 
 
+//=================================================================================================
+// Propagate and check:
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
+
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == mpl_False)
+            st = false;
+        else if (value(p) != mpl_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        // here we may choose a wrong literal
+        // in Glucose if the clause is binary!
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking
+        cancelUntil(level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
+
 /*_________________________________________________________________________________________________
 |
 |  propagate : [void]  ->  [Clause*]
-|  
+|
 |  Description:
 |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
 |    otherwise CRef_Undef.
-|  
+|
 |    Post-conditions:
 |      * the propagation queue is empty, even if there was a conflict.
 |________________________________________________________________________________________________@*/
@@ -647,21 +701,21 @@
         vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
         for (int k = 0; k < ws_bin.size(); k++){
             Lit the_other = ws_bin[k].blocker;
-            if (value(the_other) == l_False){
+            if (value(the_other) == mpl_False){
                 confl = ws_bin[k].cref;
-#ifdef LOOSE_PROP_STAT
+#ifdef MAPLESAT_LOOSE_PROP_STAT
                 return confl;
 #else
                 goto ExitProp;
 #endif
-            }else if(value(the_other) == l_Undef)
+            }else if(value(the_other) == mpl_Undef)
                 uncheckedEnqueue(the_other, ws_bin[k].cref);
         }
 
         for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
+            if (value(blocker) == mpl_True){
                 *j++ = *i++; continue; }
 
             // Make sure the false literal is data[1]:
@@ -676,19 +730,19 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit     first = c[0];
             Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
+            if (first != blocker && value(first) == mpl_True){
                 *j++ = w; continue; }
 
             // Look for new watch:
             for (int k = 2; k < c.size(); k++)
-                if (value(c[k]) != l_False){
+                if (value(c[k]) != mpl_False){
                     c[1] = c[k]; c[k] = false_lit;
                     watches[~c[1]].push(w);
                     goto NextClause; }
 
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if (value(first) == l_False){
+            if (value(first) == mpl_False){
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -702,9 +756,11 @@
         ws.shrink(i - j);
     }
 
+#ifndef MAPLESAT_LOOSE_PROP_STAT
 ExitProp:;
     propagations += num_props;
     simpDB_props -= num_props;
+#endif
 
     return confl;
 }
@@ -713,12 +769,12 @@
 /*_________________________________________________________________________________________________
 |
 |  reduceDB : ()  ->  [void]
-|  
+|
 |  Description:
 |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
 |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
 |________________________________________________________________________________________________@*/
-struct reduceDB_lt { 
+struct reduceDB_lt {
     ClauseAllocator& ca;
     reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
     bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
@@ -726,7 +782,7 @@
 void Solver::reduceDB()
 {
     int     i, j;
-    //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
+    //if (local_learnts_dirty) cleanLearnts(learnts_local, MAPLESAT_LOCAL);
     //local_learnts_dirty = false;
 
     sort(learnts_local, reduceDB_lt(ca));
@@ -734,13 +790,14 @@
     int limit = learnts_local.size() / 2;
     for (i = j = 0; i < learnts_local.size(); i++){
         Clause& c = ca[learnts_local[i]];
-        if (c.mark() == LOCAL)
+        if (c.mark() == MAPLESAT_LOCAL) {
             if (c.removable() && !locked(c) && i < limit)
                 removeClause(learnts_local[i]);
             else{
                 if (!c.removable()) limit++;
                 c.removable(true);
                 learnts_local[j++] = learnts_local[i]; }
+        }
     }
     learnts_local.shrink(i - j);
 
@@ -751,15 +808,16 @@
     int i, j;
     for (i = j = 0; i < learnts_tier2.size(); i++){
         Clause& c = ca[learnts_tier2[i]];
-        if (c.mark() == TIER2)
+        if (c.mark() == MAPLESAT_TIER2) {
             if (!locked(c) && c.touched() + 30000 < conflicts){
                 learnts_local.push(learnts_tier2[i]);
-                c.mark(LOCAL);
+                c.mark(MAPLESAT_LOCAL);
                 //c.removable(true);
                 c.activity() = 0;
                 claBumpActivity(c);
             }else
                 learnts_tier2[j++] = learnts_tier2[i];
+        }
     }
     learnts_tier2.shrink(i - j);
 }
@@ -782,7 +840,7 @@
 {
     vec<Var> vs;
     for (Var v = 0; v < nVars(); v++)
-        if (decision[v] && value(v) == l_Undef)
+        if (decision[v] && value(v) == mpl_Undef)
             vs.push(v);
 
     order_heap_no_r  .build(vs);
@@ -793,7 +851,7 @@
 /*_________________________________________________________________________________________________
 |
 |  simplify : [void]  ->  [bool]
-|  
+|
 |  Description:
 |    Simplify the clause database according to the current top-level assigment. Currently, the only
 |    thing done here is the removal of satisfied clauses, but more things can be put here.
@@ -809,9 +867,9 @@
         return true;
 
     // Remove satisfied clauses:
-    safeRemoveSatisfiedCompact(learnts_core, CORE);
-    safeRemoveSatisfiedCompact(learnts_tier2, TIER2);
-    safeRemoveSatisfiedCompact(learnts_local, LOCAL);
+    safeRemoveSatisfiedCompact(learnts_core, MAPLESAT_CORE);
+    safeRemoveSatisfiedCompact(learnts_tier2, MAPLESAT_TIER2);
+    safeRemoveSatisfiedCompact(learnts_local, MAPLESAT_LOCAL);
     if (remove_satisfied)        // Can be turned off.
         removeSatisfied(clauses);
 
@@ -834,9 +892,9 @@
     assert(ca[cr].size() >= 2);
 
     Clause& c = ca[cr];
-    if (drup_file) // Hackish.
+    if (drup_file) { // Hackish.
         if (c.mark() != 1){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
             binDRUP('d', add_oc, drup_file); // 'add_oc' not 'c'.
 #else
             for (int i = 0; i < add_oc.size(); i++)
@@ -845,15 +903,16 @@
 #endif
         }else
             printf("c Bug: removeClauseHack(). I don't expect this to happen.\n");
+    }
 
     // TODO: dirty hack to exploit 'detachClause'. 'c' hasn't shrunk yet, so this will work fine.
     c[0] = watched0, c[1] = watched1;
     detachClause(cr);
     // Don't leave pointers to free'd memory!
     if (locked(c)){
-        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
+        Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == mpl_True ? c[0] : c[1]);
         vardata[var(implied)].reason = CRef_Undef; }
-    c.mark(1); 
+    c.mark(1);
     ca.free(cr);
 }
 
@@ -872,10 +931,10 @@
 
         // Remove false literals at the same time.
         for (k = l = 0; k < c.size(); k++)
-            if (value(c[k]) == l_True){
+            if (value(c[k]) == mpl_True){
                 removeClauseHack(cs[i], c0, c1);
                 goto NextClause; // Clause already satisfied; forget about it.
-            }else if (value(c[k]) == l_Undef)
+            }else if (value(c[k]) == mpl_Undef)
                 c[l++] = c[k];
         assert(1 < l && l <= k);
 
@@ -888,13 +947,13 @@
             int m = c.mark();
             CRef cr = ca.alloc(add_tmp, learnt); // Caution! 'alloc' may invalidate the 'c' reference.
             if (learnt){
-                if (m != CORE) learnts_core.push(cr);
-                ca[cr].mark(CORE);
+                if (m != MAPLESAT_CORE) learnts_core.push(cr);
+                ca[cr].mark(MAPLESAT_CORE);
                 ca[cr].set_lbd(lbd > 2 ? 2 : lbd); }
             attachClause(cr);
 
             if (drup_file){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
                 binDRUP('a', add_tmp, drup_file);
 #else
                 for (int i = 0; i < add_tmp.size(); i++)
@@ -914,7 +973,7 @@
         else            clauses_literals -= (k - l);
 
         if (drup_file && k != l){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
             binDRUP('a', c, drup_file);
             binDRUP('d', add_oc, drup_file);
 #else
@@ -938,14 +997,14 @@
 /*_________________________________________________________________________________________________
 |
 |  search : (nof_conflicts : int) (params : const SearchParams&)  ->  [lbool]
-|  
+|
 |  Description:
-|    Search for a model the specified number of conflicts. 
-|  
+|    Search for a model the specified number of conflicts.
+|
 |  Output:
-|    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
-|    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
-|    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
+|    'mpl_True' if a partial assigment that is consistent with respect to the clauseset is found. If
+|    all variables are decision variables, this means that the clause set is satisfiable. 'mpl_False'
+|    if the clause set is unsatisfiable. 'mpl_Undef' if the bound on number of conflicts is reached.
 |________________________________________________________________________________________________@*/
 lbool Solver::search(int& nof_conflicts)
 {
@@ -964,7 +1023,7 @@
 
             conflicts++; nof_conflicts--;
             if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
-            if (decisionLevel() == 0) return l_False;
+            if (decisionLevel() == 0) return mpl_False;
 
             learnt_clause.clear();
             analyze(confl, learnt_clause, backtrack_level, lbd);
@@ -984,10 +1043,10 @@
                 ca[cr].set_lbd(lbd);
                 if (lbd <= core_lbd_cut){
                     learnts_core.push(cr);
-                    ca[cr].mark(CORE);
+                    ca[cr].mark(MAPLESAT_CORE);
                 }else if (lbd <= 6){
                     learnts_tier2.push(cr);
-                    ca[cr].mark(TIER2);
+                    ca[cr].mark(MAPLESAT_TIER2);
                     ca[cr].touched() = conflicts;
                 }else{
                     learnts_local.push(cr);
@@ -996,7 +1055,7 @@
                 uncheckedEnqueue(learnt_clause[0], cr);
             }
             if (drup_file){
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
                 binDRUP('a', learnt_clause, drup_file);
 #else
                 for (int i = 0; i < learnt_clause.size(); i++)
@@ -1013,9 +1072,9 @@
                 max_learnts             *= learntsize_inc;
 
                 if (verbosity >= 1)
-                    printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n", 
-                           (int)conflicts, 
-                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals, 
+                    printf("c | %9d | %7d %8d %8d | %8d %8d %6.0f | %6.3f %% |\n",
+                           (int)conflicts,
+                           (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
                            (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             }*/
 
@@ -1029,16 +1088,16 @@
                 restart = lbd_queue.full() && (lbd_queue.avg() * K > global_lbd_sum / conflicts_glue);
                 cached = true;
             }
-            if (restart /*|| !withinBudget()*/){
+            if (restart || !withinBudget()){
                 lbd_queue.clear();
                 // Reached bound on number of conflicts:
                 progress_estimate = progressEstimate();
                 cancelUntil(0);
-                return l_Undef; }
+                return mpl_Undef; }
 
             // Simplify the set of problem clauses:
             if (decisionLevel() == 0 && !simplify(true))
-                return l_False;
+                return mpl_False;
 
             if (conflicts >= next_T2_reduce){
                 next_T2_reduce = conflicts + 10000;
@@ -1048,29 +1107,29 @@
                 reduceDB(); }
 
             Lit next = lit_Undef;
-            /*while (decisionLevel() < assumptions.size()){
+            while (decisionLevel() < assumptions.size()){
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if (value(p) == l_True){
+                if (value(p) == mpl_True){
                     // Dummy decision level:
                     newDecisionLevel();
-                }else if (value(p) == l_False){
+                }else if (value(p) == mpl_False){
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return mpl_False;
                 }else{
                     next = p;
                     break;
                 }
             }
 
-            if (next == lit_Undef)*/{
+            if (next == lit_Undef) {
                 // New variable decision:
                 decisions++;
                 next = pickBranchLit();
 
                 if (next == lit_Undef)
                     // Model found:
-                    return l_True;
+                    return mpl_True;
             }
 
             // Increase decision level and enqueue 'next'
@@ -1107,35 +1166,35 @@
 
  */
 
-static double luby(double y, int x){
+// static double luby(double y, int x){
 
-    // Find the finite subsequence that contains index 'x', and the
-    // size of that subsequence:
-    int size, seq;
-    for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
+//     // Find the finite subsequence that contains index 'x', and the
+//     // size of that subsequence:
+//     int size, seq;
+//     for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
+
+//     while (size-1 != x){
+//         size = (size-1)>>1;
+//         seq--;
+//         x = x % size;
+//     }
 
-    while (size-1 != x){
-        size = (size-1)>>1;
-        seq--;
-        x = x % size;
-    }
-
-    return pow(y, seq);
-}
+//     return pow(y, seq);
+// }
 
 // NOTE: assumptions passed in member-variable 'assumptions'.
 lbool Solver::solve_()
 {
     model.clear();
     conflict.clear();
-    if (!ok) return l_False;
+    if (!ok) return mpl_False;
 
     solves++;
 
     max_learnts               = nClauses() * learntsize_factor;
     learntsize_adjust_confl   = learntsize_adjust_start_confl;
     learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
-    lbool   status            = l_Undef;
+    lbool   status            = mpl_Undef;
 
     if (verbosity >= 1){
         printf("c ============================[ Search Statistics ]==============================\n");
@@ -1148,38 +1207,43 @@
 
     glucose_restart = true;
     int init = 10000;
-    while (status == l_Undef && init > 0 /*&& withinBudget()*/)
+    while (status == mpl_Undef && init > 0 && withinBudget())
        status = search(init);
-    glucose_restart = false;
 
-    // Search:
-    int phase_allotment = 100;
-    for (;;){
-        int weighted = glucose_restart ? phase_allotment * 2 : phase_allotment;
-        fflush(stdout);
+    if (status == mpl_Undef) {
+        glucose_restart = false;
+
+        // Search:
+        int phase_allotment = 100;
+        for (;;){
+            int weighted = glucose_restart ? phase_allotment * 2 : phase_allotment;
+            fflush(stdout);
+
+            while (status == mpl_Undef && weighted > 0 && withinBudget())
+                status = search(weighted);
+            if (status != mpl_Undef || !withinBudget())
+                break; // Should break here for correctness in incremental SAT solving.
 
-        while (status == l_Undef && weighted > 0 /*&& withinBudget()*/)
-            status = search(weighted);
-        if (status != l_Undef /*|| !withinBudget()*/)
-            break; // Should break here for correctness in incremental SAT solving.
-
-        glucose_restart = !glucose_restart;
-        if (!glucose_restart)
-            phase_allotment += phase_allotment / 10;
+            glucose_restart = !glucose_restart;
+            if (!glucose_restart)
+                phase_allotment += phase_allotment / 10;
+        }
     }
 
     if (verbosity >= 1)
         printf("c ===============================================================================\n");
 
-#ifdef BIN_DRUP
-    if (drup_file && status == l_False) binDRUP_flush(drup_file);
+#ifdef MAPLESAT_BIN_DRUP
+    if (drup_file && status == mpl_False) binDRUP_flush(drup_file);
+#else
+    if (drup_file && status == mpl_False) fprintf(drup_file, "0\n");
 #endif
 
-    if (status == l_True){
+    if (status == mpl_True){
         // Extend & copy model:
         model.growTo(nVars());
         for (int i = 0; i < nVars(); i++) model[i] = value(i);
-    }else if (status == l_False && conflict.size() == 0)
+    }else if (status == mpl_False && conflict.size() == 0)
         ok = false;
 
     cancelUntil(0);
@@ -1188,7 +1252,7 @@
 
 //=================================================================================================
 // Writing CNF to DIMACS:
-// 
+//
 // FIXME: this needs to be rewritten completely.
 
 static Var mapVar(Var x, vec<Var>& map, Var& max)
@@ -1206,7 +1270,7 @@
     if (satisfied(c)) return;
 
     for (int i = 0; i < c.size(); i++)
-        if (value(c[i]) != l_False)
+        if (value(c[i]) != mpl_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max)+1);
     fprintf(f, "0\n");
 }
@@ -1237,12 +1301,12 @@
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]]))
             cnt++;
-        
+
     for (int i = 0; i < clauses.size(); i++)
         if (!satisfied(ca[clauses[i]])){
             Clause& c = ca[clauses[i]];
             for (int j = 0; j < c.size(); j++)
-                if (value(c[j]) != l_False)
+                if (value(c[j]) != mpl_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -1252,7 +1316,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for (int i = 0; i < assumptions.size(); i++){
-        assert(value(assumptions[i]) != l_False);
+        assert(value(assumptions[i]) != mpl_False);
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max)+1);
     }
 
@@ -1319,11 +1383,11 @@
 {
     // Initialize the next region to a size corresponding to the estimated utilization degree. This
     // is not precise but should avoid some unnecessary reallocations for the new region:
-    ClauseAllocator to(ca.size() - ca.wasted()); 
+    ClauseAllocator to(ca.size() - ca.wasted());
 
     relocAll(to);
     if (verbosity >= 2)
-        printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
+        printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
                ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
     to.moveTo(ca);
 }
@@ -1356,7 +1420,7 @@
         int first = l;
         do{
             Lit p = toLit(l);
-            if (value(p) == l_Undef && !discovered[toInt(p)] &&
+            if (value(p) == mpl_Undef && !discovered[toInt(p)] &&
                     (!roots_only || isRoot(p, use_bin_learnts)) &&
                     implExistsByBin(p, use_bin_learnts)){
                 stamp_time = stamp(p, stamp_time, use_bin_learnts);
@@ -1377,7 +1441,7 @@
 
 int Solver::stamp(Lit p, int stamp_time, bool use_bin_learnts)
 {
-    assert(value(p) == l_Undef && !discovered[toInt(p)] && !finished[toInt(p)]);
+    assert(value(p) == mpl_Undef && !discovered[toInt(p)] && !finished[toInt(p)]);
     assert(rec_stack.size() == 0 && scc.size() == 0);
 
     int start_stamp = 0;
@@ -1414,7 +1478,7 @@
                 for (int k = 0; k < ws.size(); k++){
                     Lit the_other = ws[k].blocker;
 
-                    if (value(the_other) == l_Undef
+                    if (value(the_other) == mpl_Undef
                      && !seen[toInt(the_other)]
                      && undiscovered == !discovered[toInt(the_other)])
 //                     && (use_bin_learnts || !ca[ws[k].cref].learnt()))
@@ -1450,8 +1514,8 @@
                      failed = parent[toInt(failed)])
                     assert(failed != lit_Undef);
 
-                if (drup_file && value(~failed) != l_True){
-#ifdef BIN_DRUP
+                if (drup_file && value(~failed) != mpl_True){
+#ifdef MAPLESAT_BIN_DRUP
                     assert(add_tmp.size() == 0);
                     add_tmp.push(~failed);
                     binDRUP('a', add_tmp, drup_file);
@@ -1501,14 +1565,14 @@
 }
 
 bool Solver::implExistsByBin(Lit p, bool use_bin_learnts) const {
-    assert(value(p) == l_Undef);
+    assert(value(p) == mpl_Undef);
 
     const vec<Watcher>& ws = watches_bin[p];
     for (int i = 0; i < ws.size(); i++){
         Lit the_other = ws[i].blocker;
-        assert(value(the_other) != l_False); // Propagate then.
+        assert(value(the_other) != mpl_False); // Propagate then.
 
-        if (value(the_other) != l_True && !discovered[toInt(the_other)])
+        if (value(the_other) != mpl_True && !discovered[toInt(the_other)])
             if (use_bin_learnts || !ca[ws[i].cref].learnt())
                 return true;
     }
diff -Naur solvers/maplesat/core/Solver.h solvers/maple/core/Solver.h
--- solvers/maplesat/core/Solver.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/core/Solver.h	2019-03-17 23:28:05.000000000 +0000
@@ -20,33 +20,33 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Solver_h
-#define Minisat_Solver_h
+#ifndef Maplesat_Solver_h
+#define Maplesat_Solver_h
 
-#define BIN_DRUP
+// #define MAPLESAT_BIN_DRUP
 
-#define GLUCOSE23
-//#define INT_QUEUE_AVG
-//#define LOOSE_PROP_STAT
-
-#ifdef GLUCOSE23
-  #define INT_QUEUE_AVG
-  #define LOOSE_PROP_STAT
+#define MAPLESAT_GLUCOSE23
+//#define MAPLESAT_INT_QUEUE_AVG
+//#define MAPLESAT_LOOSE_PROP_STAT
+
+#ifdef MAPLESAT_GLUCOSE23
+  #define MAPLESAT_INT_QUEUE_AVG
+  #define MAPLESAT_LOOSE_PROP_STAT
 #endif
 
-#include "mtl/Vec.h"
-#include "mtl/Heap.h"
-#include "mtl/Alg.h"
-#include "utils/Options.h"
-#include "core/SolverTypes.h"
+#include "maplesat/mtl/Vec.h"
+#include "maplesat/mtl/Heap.h"
+#include "maplesat/mtl/Alg.h"
+#include "maplesat/utils/Options.h"
+#include "maplesat/core/SolverTypes.h"
 
 
 // Don't change the actual numbers.
-#define LOCAL 0
-#define TIER2 2
-#define CORE  3
+#define MAPLESAT_LOCAL 0
+#define MAPLESAT_TIER2 2
+#define MAPLESAT_CORE  3
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Solver -- the main class:
@@ -62,7 +62,7 @@
     public:
         MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
         inline bool   full () const { return q_sz == max_sz; }
-#ifdef INT_QUEUE_AVG
+#ifdef MAPLESAT_INT_QUEUE_AVG
         inline T      avg  () const { assert(full()); return sum / max_sz; }
 #else
         inline double avg  () const { assert(full()); return sum / (double) max_sz; }
@@ -88,11 +88,11 @@
     //
     Var     newVar    (bool polarity = true, bool dvar = true); // Add a new variable with parameters specifying variable mode.
 
-    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver. 
+    bool    addClause (const vec<Lit>& ps);                     // Add a clause to the solver.
     bool    addEmptyClause();                                   // Add the empty clause, making the solver contradictory.
-    bool    addClause (Lit p);                                  // Add a unit clause to the solver. 
-    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver. 
-    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver. 
+    bool    addClause (Lit p);                                  // Add a unit clause to the solver.
+    bool    addClause (Lit p, Lit q);                           // Add a binary clause to the solver.
+    bool    addClause (Lit p, Lit q, Lit r);                    // Add a ternary clause to the solver.
     bool    addClause_(      vec<Lit>& ps);                     // Add a clause to the solver without making superflous internal copy. Will
                                                                 // change the passed vector 'ps'.
 
@@ -106,6 +106,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
     void    toDimacs     (const char *file, const vec<Lit>& assumps);
@@ -116,9 +117,9 @@
     void    toDimacs     (const char* file, Lit p);
     void    toDimacs     (const char* file, Lit p, Lit q);
     void    toDimacs     (const char* file, Lit p, Lit q, Lit r);
-    
+
     // Variable mode:
-    // 
+    //
     void    setPolarity    (Var v, bool b); // Declare which polarity the decision heuristic should use for a variable. Requires mode 'polarity_user'.
     void    setDecisionVar (Var v, bool b); // Declare if a variable should be eligible for selection in the decision heuristic.
 
@@ -156,7 +157,8 @@
 
     // Mode of operation:
     //
-    FILE*     drup_file;
+    FILE     *drup_file;
+    void     *drup_pyfile;
     int       verbosity;
     double    step_size;
     double    step_size_dec;
@@ -334,7 +336,7 @@
         return lbd;
     }
 
-#ifdef BIN_DRUP
+#ifdef MAPLESAT_BIN_DRUP
     static int buf_len;
     static unsigned char drup_buf[];
     static unsigned char* buf_ptr;
@@ -342,7 +344,7 @@
     static inline void byteDRUP(Lit l){
         unsigned int u = 2 * (var(l) + 1) + sign(l);
         do{
-            *buf_ptr++ = u & 0x7f | 0x80; buf_len++;
+            *buf_ptr++ = (u & 0x7f) | 0x80; buf_len++;
             u = u >> 7;
         }while (u);
         *(buf_ptr - 1) &= 0x7f; // End marker of this unsigned number.
@@ -366,7 +368,8 @@
     }
 
     static inline void binDRUP_flush(FILE* drup_file){
-        fwrite_unlocked(drup_buf, sizeof(unsigned char), buf_len, drup_file);
+        fwrite(drup_buf, sizeof(unsigned char), buf_len, drup_file);
+        // fwrite_unlocked(drup_buf, sizeof(unsigned char), buf_len, drup_file);
         buf_ptr = drup_buf; buf_len = 0;
     }
 #endif
@@ -435,15 +438,15 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != mpl_Undef ? value(p) != mpl_False : (uncheckedEnqueue(p, from), true); }
 inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
 inline bool     Solver::locked          (const Clause& c) const {
-    int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
-    return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
+    int i = c.size() != 2 ? 0 : (value(c[0]) == mpl_True ? 0 : 1);
+    return value(c[i]) == mpl_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
 }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
@@ -459,8 +462,8 @@
 inline int      Solver::nVars         ()      const   { return vardata.size(); }
 inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
 inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
-inline void     Solver::setDecisionVar(Var v, bool b) 
-{ 
+inline void     Solver::setDecisionVar(Var v, bool b)
+{
     if      ( b && !decision[v]) dec_vars++;
     else if (!b &&  decision[v]) dec_vars--;
 
@@ -482,11 +485,11 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == mpl_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == mpl_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == mpl_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == mpl_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == mpl_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
diff -Naur solvers/maplesat/core/SolverTypes.h solvers/maple/core/SolverTypes.h
--- solvers/maplesat/core/SolverTypes.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/core/SolverTypes.h	2019-03-17 23:19:41.000000000 +0000
@@ -21,18 +21,18 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_SolverTypes_h
-#define Minisat_SolverTypes_h
+#ifndef Maplesat_SolverTypes_h
+#define Maplesat_SolverTypes_h
 
 #include <assert.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Alg.h"
-#include "mtl/Vec.h"
-#include "mtl/Map.h"
-#include "mtl/Alloc.h"
+#include "maplesat/mtl/IntTypes.h"
+#include "maplesat/mtl/Alg.h"
+#include "maplesat/mtl/Vec.h"
+#include "maplesat/mtl/Map.h"
+#include "maplesat/mtl/Alloc.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -49,7 +49,7 @@
     int     x;
 
     // Use this as a constructor:
-    friend Lit mkLit(Var var, bool sign = false);
+    friend Lit mkLit(Var var, bool sign);
 
     bool operator == (Lit p) const { return x == p.x; }
     bool operator != (Lit p) const { return x != p.x; }
@@ -57,16 +57,16 @@
 };
 
 
-inline  Lit  mkLit     (Var var, bool sign) { Lit p; p.x = var + var + (int)sign; return p; }
+inline  Lit  mkLit     (Var var, bool sign=false) { Lit p; p.x = var + var + (int)sign; return p; }
 inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
 inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 inline  bool sign      (Lit p)              { return p.x & 1; }
 inline  int  var       (Lit p)              { return p.x >> 1; }
 
 // Mapping Literals to and from compact integers suitable for array indexing:
-inline  int  toInt     (Var v)              { return v; } 
-inline  int  toInt     (Lit p)              { return p.x; } 
-inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
+inline  int  toInt     (Var v)              { return v; }
+inline  int  toInt     (Lit p)              { return p.x; }
+inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; }
 
 //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
 //const Lit lit_Error = mkLit(var_Undef, true );  // }
@@ -79,13 +79,13 @@
 // Lifted booleans:
 //
 // NOTE: this implementation is optimized for the case when comparisons between values are mostly
-//       between one variable and one constant. Some care had to be taken to make sure that gcc 
+//       between one variable and one constant. Some care had to be taken to make sure that gcc
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (lbool((uint8_t)1))
-#define l_Undef (lbool((uint8_t)2))
+#define mpl_True  (lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+#define mpl_False (lbool((uint8_t)1))
+#define mpl_Undef (lbool((uint8_t)2))
 
 class lbool {
     uint8_t value;
@@ -100,7 +100,7 @@
     bool  operator != (lbool b) const { return !(*this == b); }
     lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
 
-    lbool operator && (lbool b) const { 
+    lbool operator && (lbool b) const {
         uint8_t sel = (this->value << 1) | (b.value << 3);
         uint8_t v   = (0xF7F755F4 >> sel) & 3;
         return lbool(v); }
@@ -146,14 +146,14 @@
         header.lbd       = 0;
         header.removable = 1;
 
-        for (int i = 0; i < ps.size(); i++) 
+        for (int i = 0; i < ps.size(); i++)
             data[i].lit = ps[i];
 
         if (header.has_extra){
             if (header.learnt){
-                data[header.size].act = 0; 
+                data[header.size].act = 0;
                 data[header.size+1].touched = 0;
-            }else 
+            }else
                 calcAbstraction(); }
     }
 
@@ -248,13 +248,13 @@
     void reloc(CRef& cr, ClauseAllocator& to)
     {
         Clause& c = operator[](cr);
-        
+
         if (c.reloced()) { cr = c.relocation(); return; }
-        
+
         cr = to.alloc(c, c.learnt());
         c.relocate(cr);
-        
-        // Copy extra data-fields: 
+
+        // Copy extra data-fields:
         // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
         to[cr].mark(c.mark());
         if (to[cr].learnt()){
@@ -281,7 +281,7 @@
 
  public:
     OccLists(const Deleted& d) : deleted(d) {}
-    
+
     void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
     const Vec&  operator[](const Idx& idx) const { return occs[toInt(idx)]; }
     Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
@@ -340,13 +340,13 @@
 
     typedef Map<CRef, T, CRefHash> HashTable;
     HashTable map;
-        
+
  public:
     // Size-operations:
     void     clear       ()                           { map.clear(); }
     int      size        ()                const      { return map.elems(); }
 
-    
+
     // Insert/Remove/Test mapping:
     void     insert      (CRef cr, const T& t){ map.insert(cr, t); }
     void     growTo      (CRef cr, const T& t){ map.insert(cr, t); } // NOTE: for compatibility
@@ -373,11 +373,11 @@
 /*_________________________________________________________________________________________________
 |
 |  subsumes : (other : const Clause&)  ->  Lit
-|  
+|
 |  Description:
 |       Checks if clause subsumes 'other', and at the same time, if it can be used to simplify 'other'
 |       by subsumption resolution.
-|  
+|
 |    Result:
 |       lit_Error  - No subsumption or simplification
 |       lit_Undef  - Clause subsumes 'other'
diff -Naur solvers/maplesat/mtl/Alg.h solvers/maple/mtl/Alg.h
--- solvers/maplesat/mtl/Alg.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Alg.h	2019-03-17 22:57:48.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Alg_h
-#define Minisat_Alg_h
+#ifndef Maplesat_Alg_h
+#define Maplesat_Alg_h
 
-#include "mtl/Vec.h"
+#include "maplesat/mtl/Vec.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur solvers/maplesat/mtl/Alloc.h solvers/maple/mtl/Alloc.h
--- solvers/maplesat/mtl/Alloc.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Alloc.h	2019-03-17 22:57:55.000000000 +0000
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_Alloc_h
-#define Minisat_Alloc_h
+#ifndef Maplesat_Alloc_h
+#define Maplesat_Alloc_h
 
-#include "mtl/XAlloc.h"
-#include "mtl/Vec.h"
+#include "maplesat/mtl/XAlloc.h"
+#include "maplesat/mtl/Vec.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
@@ -56,7 +56,7 @@
     uint32_t size      () const      { return sz; }
     uint32_t wasted    () const      { return wasted_; }
 
-    Ref      alloc     (int size); 
+    Ref      alloc     (int size);
     void     free      (int size)    { wasted_ += size; }
 
     // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
@@ -109,14 +109,14 @@
 template<class T>
 typename RegionAllocator<T>::Ref
 RegionAllocator<T>::alloc(int size)
-{ 
+{
     // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
     assert(size > 0);
     capacity(sz + size);
 
     uint32_t prev_sz = sz;
     sz += size;
-    
+
     // Handle overflow:
     if (sz < prev_sz)
         throw OutOfMemoryException();
diff -Naur solvers/maplesat/mtl/Heap.h solvers/maple/mtl/Heap.h
--- solvers/maplesat/mtl/Heap.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Heap.h	2019-03-17 22:58:06.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Heap_h
-#define Minisat_Heap_h
+#ifndef Maplesat_Heap_h
+#define Maplesat_Heap_h
 
-#include "mtl/Vec.h"
+#include "maplesat/mtl/Vec.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
@@ -45,7 +45,7 @@
     {
         int x  = heap[i];
         int p  = parent(i);
-        
+
         while (i != 0 && lt(x, heap[p])){
             heap[i]          = heap[p];
             indices[heap[p]] = i;
@@ -103,7 +103,7 @@
 
         indices[n] = heap.size();
         heap.push(n);
-        percolateUp(indices[n]); 
+        percolateUp(indices[n]);
     }
 
 
@@ -115,7 +115,7 @@
         indices[x]       = -1;
         heap.pop();
         if (heap.size() > 1) percolateDown(0);
-        return x; 
+        return x;
     }
 
 
@@ -133,11 +133,11 @@
             percolateDown(i);
     }
 
-    void clear(bool dealloc = false) 
-    { 
+    void clear(bool dealloc = false)
+    {
         for (int i = 0; i < heap.size(); i++)
             indices[heap[i]] = -1;
-        heap.clear(dealloc); 
+        heap.clear(dealloc);
     }
 };
 
diff -Naur solvers/maplesat/mtl/IntTypes.h solvers/maple/mtl/IntTypes.h
--- solvers/maplesat/mtl/IntTypes.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/IntTypes.h	2019-03-17 22:58:19.000000000 +0000
@@ -17,8 +17,8 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_IntTypes_h
-#define Minisat_IntTypes_h
+#ifndef Maplesat_IntTypes_h
+#define Maplesat_IntTypes_h
 
 #ifdef __sun
     // Not sure if there are newer versions that support C99 headers. The
diff -Naur solvers/maplesat/mtl/Map.h solvers/maple/mtl/Map.h
--- solvers/maplesat/mtl/Map.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Map.h	2019-03-17 22:58:30.000000000 +0000
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Map_h
-#define Minisat_Map_h
+#ifndef Maplesat_Map_h
+#define Maplesat_Map_h
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
+#include "maplesat/mtl/IntTypes.h"
+#include "maplesat/mtl/Vec.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Default hash/equals functions
@@ -72,7 +72,7 @@
     bool    checkCap(int new_size) const { return new_size > cap; }
 
     int32_t index  (const K& k) const { return hash(k) % cap; }
-    void   _insert (const K& k, const D& d) { 
+    void   _insert (const K& k, const D& d) {
         vec<Pair>& ps = table[index(k)];
         ps.push(); ps.last().key = k; ps.last().data = d; }
 
@@ -96,7 +96,7 @@
         // printf(" --- rehashing, old-cap=%d, new-cap=%d\n", cap, newsize);
     }
 
-    
+
  public:
 
     Map () : table(NULL), cap(0), size(0) {}
@@ -137,7 +137,7 @@
         for (int i = 0; i < ps.size(); i++)
             if (equals(ps[i].key, k)){
                 d = ps[i].data;
-                return true; } 
+                return true; }
         return false;
     }
 
diff -Naur solvers/maplesat/mtl/Queue.h solvers/maple/mtl/Queue.h
--- solvers/maplesat/mtl/Queue.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Queue.h	2019-03-17 22:58:39.000000000 +0000
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Queue_h
-#define Minisat_Queue_h
+#ifndef Maplesat_Queue_h
+#define Maplesat_Queue_h
 
-#include "mtl/Vec.h"
+#include "maplesat/mtl/Vec.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 
diff -Naur solvers/maplesat/mtl/Sort.h solvers/maple/mtl/Sort.h
--- solvers/maplesat/mtl/Sort.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Sort.h	2019-03-17 22:58:48.000000000 +0000
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Sort_h
-#define Minisat_Sort_h
+#ifndef Maplesat_Sort_h
+#define Maplesat_Sort_h
 
-#include "mtl/Vec.h"
+#include "maplesat/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Minisat {
+namespace Maplesat {
 
 template<class T>
 struct LessThan_default {
diff -Naur solvers/maplesat/mtl/Vec.h solvers/maple/mtl/Vec.h
--- solvers/maplesat/mtl/Vec.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/Vec.h	2019-03-17 23:15:11.000000000 +0000
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Vec_h
-#define Minisat_Vec_h
+#ifndef Maplesat_Vec_h
+#define Maplesat_Vec_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "maplesat/mtl/IntTypes.h"
+#include "maplesat/mtl/XAlloc.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Automatically resizable arrays
@@ -43,7 +43,7 @@
     // Don't allow copying (error prone):
     vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              vec        (vec<T>& other) { assert(0); }
-             
+
     // Helpers for calculating next capacity:
     static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
     //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
@@ -96,7 +96,7 @@
 void vec<T>::capacity(int min_cap) {
     if (cap >= min_cap) return;
     int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
-    if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
+    if (add > INT_MAX - cap || (((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM))
         throw OutOfMemoryException();
  }
 
diff -Naur solvers/maplesat/mtl/XAlloc.h solvers/maple/mtl/XAlloc.h
--- solvers/maplesat/mtl/XAlloc.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/mtl/XAlloc.h	2019-03-17 22:59:23.000000000 +0000
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Minisat_XAlloc_h
-#define Minisat_XAlloc_h
+#ifndef Maplesat_XAlloc_h
+#define Maplesat_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 
-namespace Minisat {
+namespace Maplesat {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur solvers/maplesat/utils/Options.cc solvers/maple/utils/Options.cc
--- solvers/maplesat/utils/Options.cc	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/utils/Options.cc	2019-03-17 23:22:01.000000000 +0000
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "mtl/Sort.h"
-#include "utils/Options.h"
-#include "utils/ParseUtils.h"
+#include "maplesat/mtl/Sort.h"
+#include "maplesat/utils/Options.h"
+#include "maplesat/utils/ParseUtils.h"
 
-using namespace Minisat;
+using namespace Maplesat;
 
-void Minisat::parseOptions(int& argc, char** argv, bool strict)
+void Maplesat::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -35,18 +35,19 @@
                 printUsageAndExit(argc, argv, true);
         } else {
             bool parsed_ok = false;
-        
+
             for (int k = 0; !parsed_ok && k < Option::getOptionList().size(); k++){
                 parsed_ok = Option::getOptionList()[k]->parse(argv[i]);
 
                 // fprintf(stderr, "checking %d: %s against flag <%s> (%s)\n", i, argv[i], Option::getOptionList()[k]->name, parsed_ok ? "ok" : "skip");
             }
 
-            if (!parsed_ok)
+            if (!parsed_ok) {
                 if (strict && match(argv[i], "-"))
                     fprintf(stderr, "ERROR! Unknown flag \"%s\". Use '--%shelp' for help.\n", argv[i], Option::getHelpPrefixString()), exit(1);
                 else
                     argv[j++] = argv[i];
+            }
         }
     }
 
@@ -54,9 +55,9 @@
 }
 
 
-void Minisat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Minisat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Minisat::printUsageAndExit (int argc, char** argv, bool verbose)
+void Maplesat::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void Maplesat::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void Maplesat::printUsageAndExit (int argc, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
diff -Naur solvers/maplesat/utils/Options.h solvers/maple/utils/Options.h
--- solvers/maplesat/utils/Options.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/utils/Options.h	2019-03-17 23:15:40.000000000 +0000
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_Options_h
-#define Minisat_Options_h
+#ifndef Maplesat_Options_h
+#define Maplesat_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
-#include "utils/ParseUtils.h"
+#include "maplesat/mtl/IntTypes.h"
+#include "maplesat/mtl/Vec.h"
+#include "maplesat/utils/ParseUtils.h"
 
-namespace Minisat {
+namespace Maplesat {
 
 //==================================================================================================
 // Top-level option parse/help functions:
@@ -60,20 +60,20 @@
     struct OptionLt {
         bool operator()(const Option* x, const Option* y) {
             int test1 = strcmp(x->category, y->category);
-            return test1 < 0 || test1 == 0 && strcmp(x->type_name, y->type_name) < 0;
+            return test1 < 0 || (test1 == 0 && strcmp(x->type_name, y->type_name) < 0);
         }
     };
 
-    Option(const char* name_, 
+    Option(const char* name_,
            const char* desc_,
            const char* cate_,
-           const char* type_) : 
+           const char* type_) :
       name       (name_)
     , description(desc_)
     , category   (cate_)
     , type_name  (type_)
-    { 
-        getOptionList().push(this); 
+    {
+        getOptionList().push(this);
     }
 
  public:
@@ -135,7 +135,7 @@
     DoubleOption& operator=(double x)   { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -143,7 +143,7 @@
         char*  end;
         double tmp = strtod(span, &end);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp >= range.end && (!range.end_inclusive || tmp != range.end)){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -159,12 +159,12 @@
     }
 
     virtual void help (bool verbose = false){
-        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n", 
-                name, type_name, 
-                range.begin_inclusive ? '[' : '(', 
+        fprintf(stderr, "  -%-12s = %-8s %c%4.2g .. %4.2g%c (default: %g)\n",
+                name, type_name,
+                range.begin_inclusive ? '[' : '(',
                 range.begin,
                 range.end,
-                range.end_inclusive ? ']' : ')', 
+                range.end_inclusive ? ']' : ')',
                 value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
@@ -187,13 +187,13 @@
  public:
     IntOption(const char* c, const char* n, const char* d, int32_t def = int32_t(), IntRange r = IntRange(INT32_MIN, INT32_MAX))
         : Option(n, d, c, "<int32>"), range(r), value(def) {}
- 
+
     operator   int32_t   (void) const { return value; }
     operator   int32_t&  (void)       { return value; }
     IntOption& operator= (int32_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -201,7 +201,7 @@
         char*   end;
         int32_t tmp = strtol(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -249,13 +249,13 @@
  public:
     Int64Option(const char* c, const char* n, const char* d, int64_t def = int64_t(), Int64Range r = Int64Range(INT64_MIN, INT64_MAX))
         : Option(n, d, c, "<int64>"), range(r), value(def) {}
- 
+
     operator     int64_t   (void) const { return value; }
     operator     int64_t&  (void)       { return value; }
     Int64Option& operator= (int64_t x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -263,7 +263,7 @@
         char*   end;
         int64_t tmp = strtoll(span, &end, 10);
 
-        if (end == NULL) 
+        if (end == NULL)
             return false;
         else if (tmp > range.end){
             fprintf(stderr, "ERROR! value <%s> is too large for option \"%s\".\n", span, name);
@@ -282,15 +282,15 @@
         if (range.begin == INT64_MIN)
             fprintf(stderr, "imin");
         else
-            fprintf(stderr, "%4"PRIi64, range.begin);
+            fprintf(stderr, "%4" PRIi64, range.begin);
 
         fprintf(stderr, " .. ");
         if (range.end == INT64_MAX)
             fprintf(stderr, "imax");
         else
-            fprintf(stderr, "%4"PRIi64, range.end);
+            fprintf(stderr, "%4" PRIi64, range.end);
 
-        fprintf(stderr, "] (default: %"PRIi64")\n", value);
+        fprintf(stderr, "] (default: %" PRIi64")\n", value);
         if (verbose){
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
@@ -307,7 +307,7 @@
 {
     const char* value;
  public:
-    StringOption(const char* c, const char* n, const char* d, const char* def = NULL) 
+    StringOption(const char* c, const char* n, const char* d, const char* def = NULL)
         : Option(n, d, c, "<string>"), value(def) {}
 
     operator      const char*  (void) const     { return value; }
@@ -315,7 +315,7 @@
     StringOption& operator=    (const char* x)  { value = x; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
+        const char* span = str;
 
         if (!match(span, "-") || !match(span, name) || !match(span, "="))
             return false;
@@ -330,7 +330,7 @@
             fprintf(stderr, "\n        %s\n", description);
             fprintf(stderr, "\n");
         }
-    }    
+    }
 };
 
 
@@ -343,7 +343,7 @@
     bool value;
 
  public:
-    BoolOption(const char* c, const char* n, const char* d, bool v) 
+    BoolOption(const char* c, const char* n, const char* d, bool v)
         : Option(n, d, c, "<bool>"), value(v) {}
 
     operator    bool     (void) const { return value; }
@@ -351,8 +351,8 @@
     BoolOption& operator=(bool b)     { value = b; return *this; }
 
     virtual bool parse(const char* str){
-        const char* span = str; 
-        
+        const char* span = str;
+
         if (match(span, "-")){
             bool b = !match(span, "no-");
 
diff -Naur solvers/maplesat/utils/ParseUtils.h solvers/maple/utils/ParseUtils.h
--- solvers/maplesat/utils/ParseUtils.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/utils/ParseUtils.h	2019-03-17 22:57:35.000000000 +0000
@@ -18,15 +18,15 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_ParseUtils_h
-#define Minisat_ParseUtils_h
+#ifndef Maplesat_ParseUtils_h
+#define Maplesat_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
 
 #include <zlib.h>
 
-namespace Minisat {
+namespace Maplesat {
 
 //-------------------------------------------------------------------------------------------------
 // A simple buffered character stream class:
@@ -104,7 +104,7 @@
 
     in += i;
 
-    return true; 
+    return true;
 }
 
 // String matching: consumes characters eagerly, but does not require random access iterator.
diff -Naur solvers/maplesat/utils/System.cc solvers/maple/utils/System.cc
--- solvers/maplesat/utils/System.cc	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/utils/System.cc	2019-03-17 22:57:20.000000000 +0000
@@ -18,14 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "utils/System.h"
+#include "maplesat/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdio.h>
 #include <stdlib.h>
 
-using namespace Minisat;
+using namespace Maplesat;
 
 // TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
 // one for reading the current virtual memory size.
@@ -67,14 +67,14 @@
     return peak_kb;
 }
 
-double Minisat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Minisat::memUsedPeak() { 
+double Maplesat::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double Maplesat::memUsedPeak() {
     double peak = memReadPeak() / 1024;
     return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__)
 
-double Minisat::memUsed(void) {
+double Maplesat::memUsed(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
@@ -84,12 +84,12 @@
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Minisat::memUsed(void) {
+double Maplesat::memUsed(void) {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
 
 #else
-double Minisat::memUsed() { 
+double Maplesat::memUsed() {
     return 0; }
 #endif
diff -Naur solvers/maplesat/utils/System.h solvers/maple/utils/System.h
--- solvers/maplesat/utils/System.h	2019-03-18 22:31:57.000000000 +0000
+++ solvers/maple/utils/System.h	2019-03-17 22:56:55.000000000 +0000
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Minisat_System_h
-#define Minisat_System_h
+#ifndef Maplesat_System_h
+#define Maplesat_System_h
 
 #if defined(__linux__)
 #include <fpu_control.h>
 #endif
 
-#include "mtl/IntTypes.h"
+#include "maplesat/mtl/IntTypes.h"
 
 //-------------------------------------------------------------------------------------------------
 
-namespace Minisat {
+namespace Maplesat {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 extern double memUsed();            // Memory in mega bytes (returns 0 for unsupported architectures).
@@ -43,14 +43,14 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Minisat::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double Maplesat::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Minisat::cpuTime(void) {
+static inline double Maplesat::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
